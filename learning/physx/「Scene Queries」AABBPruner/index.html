<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="XqWEZ-KjvQT4IfXzxYvH-PEc--_zN6GqthY2jBsqOs4"><meta name="msvalidate.01" content="4E28E3FDD5912EBBB84869B17359650D"><meta name="baidu-site-verification" content="code-dwpSTDBLS2"><link rel="alternate" type="application/rss+xml" title="鑫酱" href="https://hakuya.me/rss.xml"><link rel="alternate" type="application/atom+xml" title="鑫酱" href="https://hakuya.me/atom.xml"><link rel="alternate" type="application/json" title="鑫酱" href="https://hakuya.me/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="PhysX,AABBPruner,Scene Queries"><link rel="canonical" href="https://hakuya.me/learning/physx/%E3%80%8CScene%20Queries%E3%80%8DAABBPruner/"><title>「Scene Queries」AABBPruner - 物理引擎 - 学习 | 个人博客 = 鑫酱 = 笔记本</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">「Scene Queries」AABBPruner</h1><div class="meta"><span class="item" title="创建时间：2022-09-16 16:01:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-09-16T16:01:00+08:00">2022-09-16</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>10k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>9 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">个人博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (18).jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (24).jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (8).jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper_2.jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (10).jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper_4.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learning/" itemprop="item" rel="index" title="分类于 学习"><span itemprop="name">学习</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learning/physx/" itemprop="item" rel="index" title="分类于 物理引擎"><span itemprop="name">物理引擎</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hakuya.me/learning/physx/%E3%80%8CScene%20Queries%E3%80%8DAABBPruner/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="鑫酱(●'◡'●)"><meta itemprop="description" content="笔记本, 整天摸鱼，却妄想拯救世界的技术宅"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鑫酱"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>以下为个人学习笔记整理。参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm52aWRpYS5jb20vZ2FtZXdvcmtzL2NvbnRlbnQvZ2FtZXdvcmtzbGlicmFyeS9waHlzeC9ndWlkZS9NYW51YWwvR2VvbWV0cnlRdWVyaWVzLmh0bWwjZ2VvbWV0cnlxdWVyaWVz"> PhysX SDK 3.4.0 文档</span>，部分代码可能来源于更高版本。</p></div><h1 id="scene-queriesaabbpruner"><a class="anchor" href="#scene-queriesaabbpruner">#</a> 「Scene Queries」AABBPruner</h1><p>本篇基于 <strong>「Scene Queries」AABBTree</strong> 的扩展，阅读之前建议先了解 AABBTree。（￣︶￣）↗</p><p>如果说 AABBTree 是场景查询中最基础的数据结构，那么 <strong>AABBPruner</strong> 则是再此基础上进行了全方位的优化 ——<strong> 交替帧渲染</strong>。该理论的核心是同时存储画面 A 和画面 B，其中一个展示给用户，另一个则在后台渲染，等到渲染完成后，对两者进行替换，从而实现流畅的观看体验。同理，为了保证 AABBTree 能够<strong>时刻</strong>提供场景查询功能、保证增删改的实时性，同时还可以兼顾执行效率和空间利用率，这种<strong>交替帧渲染</strong>无疑是一个比较好的方案。</p><p>首先要明确的一点是，这种方案并不是必须的，即使不使用<strong>交替帧渲染</strong>，依旧可以实现场景查询以及实时增删改，只不过执行效率和空间利用率会比较低。</p><p>接下来就从 AABBPruner 基础结构开始一点点介绍其中的实现细节：</p><h2 id="aabbpruner-中的数据组成"><a class="anchor" href="#aabbpruner-中的数据组成">#</a> AABBPruner 中的数据组成</h2><p class="gallery" data-height="500"><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220915112214887.png" alt=""></p><ul><li><strong>mAABBTree &amp;&amp; mNewTree</strong>：两棵 AABBTree。一棵是当前正在使用的 AABBTree，另一棵是正在后台构建中的 AABBTree。</li><li><strong>mBuilder</strong>：构建 mNewTree 时临时存储的构建配置信息。</li><li><strong>mBucketPruner</strong>：ExtendedBucketPruner 结构，负责对新增节点做增量构建的 IncrementAABBTree 管理结构。</li><li><strong>mPool</strong>：维护所有对象的 bound、shape、actor 关系，同时也是构建 AABBTree 和 IncrementAABBTree 的数据来源。</li><li><strong>mTreeMap &amp;&amp; mNewTreeMap</strong>：分别记录了 mAABBTree 和 mNewTree 中 bounds 和 AABBRuntimeNode 的映射关系。</li><li><strong>mCachedBoxes &amp;&amp; mNbCachedBoxes</strong>：临时缓存某个时刻 mPool 中的 bounds 数据，用来作为构建 mNewTree 的源数据。</li><li><strong>mTimeStamp</strong>：时间戳，每次构建新的 mNewTree 都会 + 1，也可以理解为帧号，区分不同时刻的修改。</li><li><strong>mNbCalls &amp;&amp; mRebuildRateHint &amp;&amp; mTotalWorkUnits &amp;&amp; mAdaptiveRebuildTerm</strong>：四个变量实现构建工作的预估<ul><li><strong>mNbCalls</strong>：表示当前构建耗费了多少 frame。</li><li><strong>mRebuildRateHint</strong>：表示预计需要多少 frame。</li><li><strong>mTotalWorkUnits</strong>：表示本次构建预计需要多少的工作量。</li><li><strong>mAdaptiveRebuildTerm</strong>：表示之前工作预估的准确性，该值会受到 mNbCalls &amp;&amp; mRebuildRateHint 影响，并影响 mTotalWorkUnits 计算。</li></ul></li><li><strong>mNewTreeFixups</strong>：记录 mNewTree 构建过程中被移除的包围盒和会被顶替到移除位置的包围盒下标。</li><li><strong>mToRefit</strong>：记录 mNewTree 构建过程中发生变化的包围盒下标。</li><li>mContextID：上下文 ID，一个 AABBPruner 持有一个，用来唯一标识。</li><li><strong>mNeedsNewTree</strong>：标识是否需要构建 mNewTree，在包围盒发生变化且支持增量构建（mIncrementalRebuild = true）的情况下，该标志为 true。</li><li><strong>mUncommittedChanges</strong>：标识有修改需要被 commit。commit 会让修改生效在 mAABBTree 上，如果 mNewTree 构建完成情况下还会进行树替换。并且在 commit 没有执行完毕的情况下，不允许执行查询操作。</li><li><strong>mIncrementalRebuild</strong>：是否支持增量构建的标记。不支持的情况下每次 commit 都会在当前帧内重新构建一棵新的 mAABBTree，否则会分布构建 mNewTree 并在构建完成后通过 commit 对 mAABBTree 进行替换。</li></ul><p>其中有几个陌生的结构之前没有提及，这里先简单的介绍一下：</p><h3 id="pruningpool"><a class="anchor" href="#pruningpool">#</a> PruningPool</h3><p><strong>PruningPool</strong> 有如下四个主要的存储结构：</p><ul><li><code>PxBounds3* mWorldBoxes</code> ：所有对象的 <strong>Bound</strong> 数据</li><li><code>PrunerPayload* mObjects</code> ：所有对象的 <strong>Shape</strong> 及 <strong>Actor</strong> 对象地址</li><li><code>PrunerHandle* mIndexToHandle</code> ：<strong>index</strong> 和 <strong>handle</strong> 的映射列表</li><li><code>PoolIndex* mHandleToIndex</code> ：<strong>handle</strong> 和 <strong>index</strong> 的映射列表</li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220720190337717.png" alt="image-20220720190337717" width="960px"></p><p><strong>PruningPool</strong> 用来存储 <strong>PrunerPayload</strong> 和 <strong>AABBBound</strong> 关联的对象列表，<strong>PrunerPayload</strong> 中存储了两个指针，分别指向 Bound 所属的 Shape 和 Actor。之前介绍 AABBTree 构建中 <strong>AABBTreeBuildParams.mAABBArray</strong> 的数据也来源于这里的 <strong>mWorldBoxes</strong>。</p><p>前三个数组是对齐的，同一下标获取到的信息同属于一个对象。而 <strong>mHandleToIndex</strong> 和 <strong>mIndexToHandle</strong> 形成了一组映射结构。外部通过 <strong>mHandleToIndex</strong> 访问内部数据，内部数据调整也需要同步修改 <strong>mIndexToHandle</strong> 映射关系，另外还有个 <strong>mFirstRecycledHandle</strong> 用于指向第一块空闲的 <strong>mHandleToIndex</strong>。</p><h4 id="removeobject"><a class="anchor" href="#removeobject">#</a> removeObject</h4><p><strong>PruningPool</strong> 移除对象有着一些特殊规则，很大程度也影响了整个 AABBPruner、AABBTree、IncrementAABBTree 的实现。</p><p>移除对象的时候被删除节点对应的 <strong>mHandleToIndex</strong> 会头插到 <strong>mFirstRecycledHandle</strong> 指向的单链表。这时候 mObjects 、mWorldBoxes、mIndexToHandle 可能会因为删除操作而导致内存不连续。为了保证连续（连续性会影响拷贝和遍历）会把最后一个元素用于填补空缺，因此还有一个替换操作。</p><p>例如这里删除掉第 1 个包围盒，然后用第 3 个进行替换：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220915154531718.png" alt="image-20220915154531718" width="960px"></p><p>这种替换操作可以使得「空间分布比较紧凑」、「移除节点的复杂度 O (1)，不需要对所有后置数据做平移」，代价是打乱了 mWorldBoxes 内两个包围盒的位置，而 AABBTree 和 IncrementAABBTree 的构建都会记录 Box 的位置用于访问，位置变更了需要批量修改非常麻烦，因此还单独维护了一个 mHandleToIndex，这样外部只需要记录 mHandleToIndex 下标即可，无需担心内部的位置发生变化。</p><blockquote><p>风险点：可以看到 <strong>mHandleToIndex</strong> 存储的内容可能是自己的下一个空闲节点也可能是 <strong>mIndexToHandle</strong> 下标，两者的数值可能相同，然而访问 Pool 的时候是通过 <strong>Handle</strong> 下标来的，因此很可能明明是个空闲节点，但依旧可能访问到数据。例如 <strong>mHandleToIndex[2]</strong> 和 <strong>mHandleToIndex[3]</strong> 最终都会指向 <strong>mIndexToHandle[1]</strong>，这点上 PhysX 并没有增加严格的保护手段。</p></blockquote><h3 id="extendedbucketpruner"><a class="anchor" href="#extendedbucketpruner">#</a> ExtendedBucketPruner</h3><p>ExtendedBucketPruner 中比较关键的结构是 MainTree 、MergedTree，以及 PrunerCore。</p><p class="gallery" data-height="650"><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220915113422926.png" alt=""></p><ul><li><p><strong>mMergedTrees</strong>：其中 mMergedTrees 是一棵棵的 AABBTree。因为 PhysX 不仅支持向场景内添加单个 Actor，还支持多个 Actor 打包成 PruningStructure 添加到场景，这里就不做过多展开，简单理解就是除了支持添加一个树节点以外，还支持添加整棵树，mMergedTrees 就是那个存储树的结构。</p></li><li><p><strong>mMainTree</strong>：mMainTree 也是一棵 AABBTree，构建的数据是基于所有 MergedTree 的根节点包围盒。由于数据量不大，因此每次新增或者删除 MergedTree 的时候都会进行全量重建。</p></li></ul><h4 id="incrementalaabbprunercoreprunercore"><a class="anchor" href="#incrementalaabbprunercoreprunercore">#</a> IncrementalAABBPrunerCore(PrunerCore)</h4><p class="gallery" data-height="260"><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220915120122464.png" alt=""></p><p>简单来说 IncrementalAABBPrunerCore 存储了两棵 CoreTree，每个 CoreTree 内维护了一棵 IncrementalAABBTree 所需的全部数据，至于为什么是两棵，我们后面再说。</p><ul><li><strong>mChangedLeaves</strong>：用来记录每次变更操作导致映射关系发生改变的节点。并在变更操作执行完毕后更新 CoreTree 的 mapping 映射。</li><li>mPool：指向的是 AABBPruner.mPool。</li><li>mCurrentTree &amp;&amp; mLastTree：标识当前使用的树和上次用过的树下标。因为只有两棵树，其实理论上记录一个就可以了。</li></ul><h5 id="coretree"><a class="anchor" href="#coretree">#</a> CoreTree</h5><p class="gallery" data-height="200"><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220915150500991.png" alt=""></p><p>CoreTree 比较简单，存储了一个 IncrementAABBTree、一个 bound 到 TreeNode 的映射，以及这棵树最后一次修改的时间戳。时间戳是用来评估这棵树的有效性的，这个后面交替渲染部分再做介绍。</p><h4 id="extendedbucketpruner-结构图"><a class="anchor" href="#extendedbucketpruner-结构图">#</a> ExtendedBucketPruner 结构图</h4><p>下图是一张简单版的 ExtendedBucketPruner 结构图，为方便更好的理解省去了很多细节：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220915151747529.png" alt="image-20220915151747529" width="960px"></p><p>如果新增的是整棵树，那么把该树添加到 MergedTree 并重新构建 MainTree。如果新增的是某个节点，那么就添加到 PrunerCore 中的 IncrementAABBTree 内。</p><h3 id="newtreefixup"><a class="anchor" href="#newtreefixup">#</a> NewTreeFixup</h3><p class="gallery" data-height="160"><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220915152038177.png" alt=""></p><p>NewTreeFixup 用来记录删除包围盒操作所影响的两个包围盒下标。至于为什么是两个，之前在 PruningPool 中也有简单的介绍，为了保证数组连续，会用末尾的数据填充到删除位置，因此删除操作实际上是一次替换，把最后一个位置的数据替换到删除位置，所以这里需要记录两个下标。具体删除细节可以回顾一下 <strong>PruningPool.removeObject</strong>。</p><h2 id="aabbpruner-的增删改"><a class="anchor" href="#aabbpruner-的增删改">#</a> AABBPruner 的增删改</h2><p>AABBPruner 增删改操作本质是都是对 AABBTree &amp;&amp; IncrementAABBTree 的封装，具体实现细节其实已经在 AABBTree 和 IncrementAABBTree 做了详细介绍，这里主要是基于更上一层的规则进行梳理：</p><h3 id="不考虑交替帧渲染的情况"><a class="anchor" href="#不考虑交替帧渲染的情况">#</a> 不考虑交替帧渲染的情况</h3><p>为了方便讨论，先介绍一下不做交替帧渲染情况下 AABBPruner 如何增删改的，以下讨论均建立在 <strong>mIncrementalRebuild = true</strong> 的情况下。</p><p>下图是简化后的 AABBPruner 结构图：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220915160705507.png" alt="image-20220915160705507" width="800px"></p><p>实际用到的结构只有 mAABBTree (AABBTree) &amp;&amp; ExtendedBucketPruner.PrunerCore.CurTree (IncrementAABBTree) 两个。</p><h4 id="新增操作"><a class="anchor" href="#新增操作">#</a> 新增操作</h4><p>由于 mAABBTree 只支持树级别的新增，<strong>并不支持节点的新增操作</strong>，因此新增逻辑的支持交给了 ExtendedBucketPruner.PrunerCore.CurTree。具体实现细节可以回顾 AABBTree 篇的 IncrementAABBTree 部分。</p><h4 id="删除操作"><a class="anchor" href="#删除操作">#</a> 删除操作</h4><p>删除操作其实分为两种情况：</p><ul><li>删除在 mAABBTree 中的节点。</li><li>删除在 ExtendedBucketPruner.PrunerCore.CurTree 中的节点。</li></ul><p>辨别方法也比较简单，AABBPruner 里面的 <strong>mTreeMap</strong> 维护了 mAABBTree 包含的全部 bound 映射，如果该映射关系内没有找到被删除的包围盒，那就一定在 ExtendedBucketPruner.PrunerCore.CurTree 里，删除细节也可以参考 AABBTree &amp;&amp; IncrementAABBTree。</p><h4 id="更新操作"><a class="anchor" href="#更新操作">#</a> 更新操作</h4><p>更新和删除比较相似，这里也不多介绍。</p><h3 id="交替帧渲染的情况"><a class="anchor" href="#交替帧渲染的情况">#</a> 交替帧渲染的情况</h3><p>引入交替帧渲染后，情况就变得复杂起来，再介绍增删改之前，先介绍一下 AABBPruner 内的 buildStep 和 commit 的构建流程。</p><h4 id="支持分布构建-buildstep"><a class="anchor" href="#支持分布构建-buildstep">#</a> 支持分布构建 buildStep</h4><p>最早提到分布构建还是在 AABBTree 的 <strong>progressiveBuild</strong> 中，这里对 AABBTree 的分布构建做了一定程度的扩展，先来看看分布构建的流程：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220916101411349.png" alt="image-20220916101411349" width="500px"></p><ul><li>BUILD_NOT_STARTED：表示还没有构建的状态，也是 AABBPruner 的初始状态。</li><li>BUILD_INIT：该状态下，会对 mPool.mWorldBoxes 做一个深拷贝，并记录在 mCachedBoxes 中，作为新树构建的源数据。</li><li>BUILD_IN_PROGRESS：拿到源数据之后，就可以开始构建 mNewTree。AABBPruner 会通过一种启发式算法控制构建次数实现平滑。</li><li>BUILD_NEW_MAPPING：无操作。</li><li>BUILD_FULL_REFIT：构建完成，需要重新生成一次 mapping 关系，并记录在 mNewTreeMap。</li><li>BUILD_LAST_FRAME：有了映射关系，这里会再计算并更新一次树节点的包围盒信息 <strong>fullRefit</strong>。</li><li>BUILD_FINISHED：无操作。</li><li>BUILD_COMMIT：这并不是一个状态，而是 commit 函数，放在这里主要是便于理解。commit 目的是能够让构建结果应用在 mAABBTree 中，类比交替帧渲染里渲染好了，需要执行交替步骤。</li></ul><h5 id="启发式的平滑算法"><a class="anchor" href="#启发式的平滑算法">#</a> 启发式的平滑算法</h5><p>如何有效的评估构建耗时并且尽可能的平滑结果，AABBPruner 定义了一个预估次数 <strong>mRebuildRateHint</strong>，默认情况下是 100 frame，可以支持动态设置。</p><p><strong>mRebuildRateHint</strong> 仅仅是一个<strong>预估值</strong>，这也意味着很可能并非实际结果，为了趋近于预估又引入了三个系数：mNbCalls、mTotalWorkUnits、mAdaptiveRebuildTerm。</p><ul><li>mNbCalls 记录的是本次构建实际消耗了多少 frame。</li><li>mAdaptiveRebuildTerm 是一个调节参数，如果实际结果超过预期说明估少了，那么就 + 1 反之 - 1，如果和上次构建的工作单元差距过大，这个值会被重置。</li><li>mTotalWorkUnits 总工作单元可以理解为一次完整构建，需要访问的包围盒次数，例如 8 个包围盒最终构建出如下的树形结构，那么总工作单元就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>+</mo><mn>5</mn><mo>=</mo><mn>13</mn></mrow><annotation encoding="application/x-tex">8 + 5 = 13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">8</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">3</span></span></span></span>，<strong>这里并不计算叶节点层</strong>。当然计算实际总工作单元没有任何意义，我们需要的是预估值，这里的计算公式大概长这样：<ul><li>leafnb：叶节数量。</li><li>depth：预估的树深度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>a</mi><mi>f</mi><mi>n</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_2(leafnb)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">n</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> 。这里假设这棵树是完全平衡的。</li><li>mTotalWorkUnits：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>W</mi><mi>o</mi><mi>r</mi><mi>k</mi><mi>U</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>∗</mo><mi>l</mi><mi>e</mi><mi>a</mi><mi>f</mi><mi>n</mi><mi>b</mi><mo>+</mo><mi>A</mi><mi>d</mi><mi>a</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>R</mi><mi>e</mi><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>d</mi><mi>T</mi><mi>e</mi><mi>r</mi><mi>m</mi><mo>∗</mo><mi>l</mi><mi>e</mi><mi>a</mi><mi>f</mi><mi>n</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TotalWorkUnits = max(0, depth * leafnb + AdaptiveRebuildTerm * leafnb)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal" style="margin-right:.13889em">W</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03148em">k</span><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="mord mathnormal">n</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">n</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">b</span><span class="mord mathnormal">u</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">n</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> 。实际会比这个复杂一些，还会参考上一次构建时的估计结果。</li></ul></li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220915163943905.png" alt="image-20220915163943905" width="500px"></p><h4 id="为什么需要构建新树"><a class="anchor" href="#为什么需要构建新树">#</a> 为什么需要构建新树🤔</h4><p>回到之前的「不交替渲染」，它也可以很好的工作，支持增删改查。为什么还要大费周章构建新的 AABBTree 呢？</p><ul><li>极端情况下，mAABBTree 的节点会全部被删除，AABBPruner 会退化成 IncrementAABBTree，在 AABBTree 章节也介绍了 IncrementAABBTree 远比 ABBTree 更加的占用内存，而且低效，唯一的优势只有支持新增节点。</li><li>删除的 mAABBTree 节点不会被回收，因此会造成内存碎片。</li><li>IncrementAABBTree 作为新增节点的<strong>暂存器</strong>，每次构建新树的时候会把 IncrementAABBTree 的节点也纳入构建，在构建完成后可以清空 IncrementAABBTree，因此频繁构建新树的情况下，IncrementAABBTree 内的节点会非常少。</li><li>构建操作虽然较为耗时，但只要能够做到很好的平滑，实际上可以减轻对于性能的开销。</li></ul><h4 id="如何保证构建新树时查询功能依旧可用"><a class="anchor" href="#如何保证构建新树时查询功能依旧可用">#</a> 如何保证构建新树时查询功能依旧可用</h4><p>可以看到构建一个新树大概需要 100 frame，这段时间里如何保证场景查询还是可靠的呢？回到之前的不交替渲染，实际上已经能够支持在运行过程中增删改了。AABBPruner 为了保证可用性的情况下为很多数据都做了副本，例如 <strong>mAABBTree &amp;&amp; mNewTree</strong>、<strong>mTreeMap &amp;&amp; mNewTreeMap</strong>、<strong>mPool.mWorldBoxes &amp;&amp; mCachedBoxes</strong>，就是为了保证构建和查询完全分离。因此在支持交替渲染情况下的 AABBPruner 可能就长这样：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220916110229854.png" alt="image-20220916110229854" width="800px"></p><p>mAABBTree + CoreTree (Last) + CoreTree (Cur) 保证了增删改查的实时性，mNewTree 构建数据源于 mAABBTree + CoreTree (Last)。因此在每次构建完成后，mAABBTree 的内容会被替换成 mNewTree，相应的 CoreTree (Last) 将会失效，而 CoreTree (Cur) 将会在下一次 mNewTree 构建开始时切换为 CoreTree (Last)。</p><h4 id="如何保证新树的一致性"><a class="anchor" href="#如何保证新树的一致性">#</a> 如何保证新树的一致性</h4><p>思考这样一个问题，假设物体的包围盒一直更新，mNewTree 就用永远都是旧的。最直接的一个例子：BUILD_INIT 状态下会拷贝 mPool.mWorldBoxes 结果构建 mNewTree，这个构建可能持续大概 100 frame，中途新的变更例如删除、添加和更新并不会影响 mNewTree，所以它还是停留在 100 frame 之前的状态，如果这时候进行替换，将会丢失这 100 frame 的全部操作。这显然是无法接受的。</p><p>AABBPruner 做法是保存这 100 frame 的全部操作，在新树构建完成时进行应用：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20220915172752137.png" alt="image-20220915172752137" width="600px"></p><h5 id="新增操作的存储"><a class="anchor" href="#新增操作的存储">#</a> 新增操作的存储</h5><p>前面提到 IncrementAABBTree 会在新树构建完成后被清理，并且节点新增都会存储在 IncrementAABBTree 内。如果把 IncrementAABBTree 作为存储新增操作的容器，则需要至少两个 IncrementAABBTree。一个是旧的 IncrementAABBTree，数据是构建开始时刻的；另一个是构建过程中新增的，也就是本次构建开始到下次构建开始的所有新增内容，旧的会在本次构建完成后清空，新的则会保留到下次构建结束。这也是为什么会有 CoreTree (Cur) 和 CoreTree (Last)。</p><h5 id="删除操作的存储"><a class="anchor" href="#删除操作的存储">#</a> 删除操作的存储</h5><p>删除操作很难对两棵树做差进行求解，最简单的办法就是存储一个操作记录，类比数据库迁移和数据恢复。AABBPruner 会把删除记录存储在 mNewTreeFixups，然后在新树构建完成后把这些删除操作再执行一次，用于保证和当前数据的一致。</p><h5 id="更新操作的存储"><a class="anchor" href="#更新操作的存储">#</a> 更新操作的存储</h5><p>更新其实类似，会记录需要更新的包围盒下标数组 mToRefit。有一点需要注意，由于 mNewTree 构建流程中本身就会执行一次全量更新 <strong>fullRefit</strong>。因此可以利用这个更新提前先把一部分的修改应用在 mNewTree 中，因此更新其实分成了两部分：</p><ul><li>在 BUILD_LAST_FRAME 下的更新：这里的更新稍微取巧了一下，没有把更新记录在 mToRefit 内，而是直接用的 mPool.mWorldBoxes 作为数据源更新的 mNewTree，好处是可以省去 mToRefit 记录的差量，直接从<strong>差值更新</strong>转为<strong>全量更新</strong>了，但是这样实际上会有一个问题。试想一下，一棵用 mCachedBoxes 构建的新树，再用 mPool.mWorldBoxes 去更新，中间差了大约 100 frame，这 100 frame 内的新增操作由于是记录在 IncrementAABBTree 里的，所以可以忽略；但删除却不行，而且删除操作会影响 bound 到 TreeNode 的映射，会导致更新的时候错乱。因此，为了解决删除时映射不一致的情况，这里会提前处理一次 mNewTreeFixups 内的删除记录，然后再做更新。</li><li>在 COMMIT 下的更新：commit 更新就不需要全量更新了，因此可以通过<strong>差值更新</strong>实现，这时候 mToRefit 才算是真真意义上的派上用场。</li></ul><h2 id="aabbpruner-的查询"><a class="anchor" href="#aabbpruner-的查询">#</a> AABBPruner 的查询</h2><p>最后让我们再看看 AABBPruner 的查询。查询接口主要有三个 raycast、sweep 和 overlap，但这里并不打算过分展开，我们仅探讨查询时需要考虑那些数据。</p><p>首先，我们已经有了足够实时的 mAABBTree，删改操作可以立马在上面得到体现；以及支持新增节点的 PrunerCore。 PrunerCore 的两棵 IncrementAABBTree 存储了不同时间段的新增节点，但即便如此它们<strong>两个都是有效的</strong>，因此所有的查询都必须<strong>查找 PrunerCore 内的两棵树以及 mAABBTree</strong>。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 先查 mAABBTree</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>mAABBTree<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	again <span class="token operator">=</span> AABBTreeRaycast<span class="token operator">&lt;</span><span class="token boolean">false</span><span class="token punctuation">,</span> AABBTree<span class="token punctuation">,</span> AABBTreeRuntimeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>mPool<span class="token punctuation">.</span><span class="token function">getObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mPool<span class="token punctuation">.</span><span class="token function">getCurrentWorldBoxes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>mAABBTree<span class="token punctuation">,</span> origin<span class="token punctuation">,</span> unitDir<span class="token punctuation">,</span> inOutDistance<span class="token punctuation">,</span> <span class="token function">PxVec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pcb<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 再查 mBucketPruner</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>again <span class="token operator">&amp;&amp;</span> mIncrementalRebuild <span class="token operator">&amp;&amp;</span> mBucketPruner<span class="token punctuation">.</span><span class="token function">getNbObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	again <span class="token operator">=</span> mBucketPruner<span class="token punctuation">.</span><span class="token function">raycast</span><span class="token punctuation">(</span>origin<span class="token punctuation">,</span> unitDir<span class="token punctuation">,</span> inOutDistance<span class="token punctuation">,</span> pcb<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>PxAgain <span class="token class-name">ExtendedBucketPruner</span><span class="token operator">::</span><span class="token function">raycast</span><span class="token punctuation">(</span><span class="token keyword">const</span> PxVec3<span class="token operator">&amp;</span> origin<span class="token punctuation">,</span> <span class="token keyword">const</span> PxVec3<span class="token operator">&amp;</span> unitDir<span class="token punctuation">,</span> PxReal<span class="token operator">&amp;</span> inOutDistance<span class="token punctuation">,</span> PrunerCallback<span class="token operator">&amp;</span> prunerCallback<span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	PxAgain again <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>	</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token comment">// 先查 mBucketPruner.mPrunerCore</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>mPrunerCore<span class="token punctuation">.</span><span class="token function">getNbObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>		again <span class="token operator">=</span> mPrunerCore<span class="token punctuation">.</span><span class="token function">raycast</span><span class="token punctuation">(</span>origin<span class="token punctuation">,</span> unitDir<span class="token punctuation">,</span> inOutDistance<span class="token punctuation">,</span> prunerCallback<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 在查 mBucketPruner.mMergedTrees</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>again <span class="token operator">&amp;&amp;</span> mExtendedBucketPrunerMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		<span class="token keyword">const</span> PxVec3 <span class="token function">extent</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>		<span class="token comment">// main tree callback</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		MainTreeRaycastPrunerCallback<span class="token operator">&lt;</span><span class="token boolean">false</span><span class="token operator">></span> <span class="token function">pcb</span><span class="token punctuation">(</span>origin<span class="token punctuation">,</span> unitDir<span class="token punctuation">,</span> extent<span class="token punctuation">,</span> prunerCallback<span class="token punctuation">,</span> mPruningPool<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>		<span class="token comment">// traverse the main tree</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		again <span class="token operator">=</span> AABBTreeRaycast<span class="token operator">&lt;</span><span class="token boolean">false</span><span class="token punctuation">,</span> AABBTree<span class="token punctuation">,</span> AABBTreeRuntimeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> PrunerPayload<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>mMergedTrees<span class="token punctuation">)</span><span class="token punctuation">,</span> mBounds<span class="token punctuation">,</span> <span class="token operator">*</span>mMainTree<span class="token punctuation">,</span> origin<span class="token punctuation">,</span> unitDir<span class="token punctuation">,</span> inOutDistance<span class="token punctuation">,</span> extent<span class="token punctuation">,</span> pcb<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token keyword">return</span> again<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到 mBucketPruner.mPrunerCore 两棵树都需要进行查询：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span>PxU32 i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_TREES<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">const</span> CoreTree<span class="token operator">&amp;</span> tree <span class="token operator">=</span> mAABBTree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>tree <span class="token operator">&amp;&amp;</span> tree<span class="token punctuation">.</span>tree<span class="token operator">-></span><span class="token function">getNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> again<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        again <span class="token operator">=</span> AABBTreeRaycast<span class="token operator">&lt;</span><span class="token boolean">false</span><span class="token punctuation">,</span> IncrementalAABBTree<span class="token punctuation">,</span> IncrementalAABBTreeNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>mPool<span class="token operator">-></span><span class="token function">getObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mPool<span class="token operator">-></span><span class="token function">getCurrentWorldBoxes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>tree<span class="token punctuation">.</span>tree<span class="token punctuation">,</span> origin<span class="token punctuation">,</span> unitDir<span class="token punctuation">,</span> inOutDistance<span class="token punctuation">,</span> <span class="token function">PxVec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pcb<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其实还有一个结构之前一直忽略了，那就是 mBucketPruner.mMergedTrees，不聊它是因为真的不是很重要 (bushi。</p><p>其实是应用场景比较少，不过还是简单介绍一下吧，mBucketPruner.mMergedTrees 的查询会先用 mMainTree 定位根节点，再通过对应的 mergedTree 查询。</p><p>另外和 CoreTree 类似，在 mNewTree 构建的时候，也会把 mMergedTrees 加入构建，并在构建完成后清理 mMergedTrees。</p><h2 id="总结"><a class="anchor" href="#总结">#</a> 总结</h2><p>本章节介绍了 AABBPruner 的实现细节，简单介绍了 <strong>AABBTreeUpdateMap</strong>，顺带填了一波 AABBTree &amp;&amp; IncrementAABBTree 中 <strong>AABBTreeBuildParams</strong> 由来的坑，并梳理了一下 AABBPruner 是如何协调 AABBTree &amp;&amp; IncrementAABBTree，通过分布构建的形式进行削峰。另外上述的讨论都是基于 <strong>mIncrementalRebuild=true</strong> 情况下，有兴趣的小伙伴可以自己思考一下关闭 mIncrementalRebuild 情况下，AABBPruner 又是如何呢。</p><div class="tags"><a href="/tags/PhysX/" rel="tag"><i class="ic i-tag"></i> PhysX</a> <a href="/tags/AABBPruner/" rel="tag"><i class="ic i-tag"></i> AABBPruner</a> <a href="/tags/Scene-Queries/" rel="tag"><i class="ic i-tag"></i> Scene Queries</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-12-29 09:36:04" itemprop="dateModified" datetime="2022-12-29T09:36:04+08:00">2022-12-29</time> </span><span id="learning/physx/「Scene Queries」AABBPruner/" class="item leancloud_visitors" data-flag-title="「Scene Queries」AABBPruner" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 充电</button><p>请我[恰饭]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="鑫酱(●'◡'●) 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="鑫酱(●'◡'●) 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>鑫酱(●'◡'●) <i class="ic i-at"><em>@</em></i>鑫酱</li><li class="link"><strong>本文链接：</strong> <a href="https://hakuya.me/learning/physx/%E3%80%8CScene%20Queries%E3%80%8DAABBPruner/" title="「Scene Queries」AABBPruner">https://hakuya.me/learning/physx/「Scene Queries」AABBPruner/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/learning/physx/%E3%80%8CScene%20Queries%E3%80%8DAABBTree%E2%80%94%E2%80%94%E4%B8%8B/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;wallpaper-1255596461.cos.ap-nanjing.myqcloud.com&#x2F;wallpaper (12).jpg" title="「Scene Queries」AABBTree——下"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 物理引擎</span><h3>「Scene Queries」AABBTree——下</h3></a></div><div class="item right"><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Simulate%E7%AF%87/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;wallpaper-1255596461.cos.ap-nanjing.myqcloud.com&#x2F;wallpaper (11).jpg" title="PhysX——Simulate篇"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 物理引擎</span><h3>PhysX——Simulate篇</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#scene-queriesaabbpruner"><span class="toc-number">1.</span> <span class="toc-text">「Scene Queries」AABBPruner</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#aabbpruner-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%84%E6%88%90"><span class="toc-number">1.1.</span> <span class="toc-text">AABBPruner 中的数据组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pruningpool"><span class="toc-number">1.1.1.</span> <span class="toc-text">PruningPool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#removeobject"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">removeObject</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extendedbucketpruner"><span class="toc-number">1.1.2.</span> <span class="toc-text">ExtendedBucketPruner</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#incrementalaabbprunercoreprunercore"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">IncrementalAABBPrunerCore(PrunerCore)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#coretree"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">CoreTree</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extendedbucketpruner-%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">ExtendedBucketPruner 结构图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newtreefixup"><span class="toc-number">1.1.3.</span> <span class="toc-text">NewTreeFixup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aabbpruner-%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9"><span class="toc-number">1.2.</span> <span class="toc-text">AABBPruner 的增删改</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%80%83%E8%99%91%E4%BA%A4%E6%9B%BF%E5%B8%A7%E6%B8%B2%E6%9F%93%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">不考虑交替帧渲染的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">新增操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">更新操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E5%B8%A7%E6%B8%B2%E6%9F%93%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">交替帧渲染的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%88%86%E5%B8%83%E6%9E%84%E5%BB%BA-buildstep"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">支持分布构建 buildStep</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E7%9A%84%E5%B9%B3%E6%BB%91%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">启发式的平滑算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9E%84%E5%BB%BA%E6%96%B0%E6%A0%91"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">为什么需要构建新树🤔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9E%84%E5%BB%BA%E6%96%B0%E6%A0%91%E6%97%B6%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD%E4%BE%9D%E6%97%A7%E5%8F%AF%E7%94%A8"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">如何保证构建新树时查询功能依旧可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%96%B0%E6%A0%91%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">如何保证新树的一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.2.4.1.</span> <span class="toc-text">新增操作的存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.2.4.2.</span> <span class="toc-text">删除操作的存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.2.4.3.</span> <span class="toc-text">更新操作的存储</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aabbpruner-%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.</span> <span class="toc-text">AABBPruner 的查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Memory%20Management%E7%AF%87/" rel="bookmark" title="PhysX——Memory Management篇">PhysX——Memory Management篇</a></li><li><a href="/learning/physx/PhysX%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E4%BB%8B%E7%BB%8D/" rel="bookmark" title="PhysX内置容器介绍">PhysX内置容器介绍</a></li><li><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Transform%E7%AF%87/" rel="bookmark" title="PhysX——Transform篇">PhysX——Transform篇</a></li><li><a href="/learning/physx/%E3%80%8CScene%20Queries%E3%80%8DAABBTree%E2%80%94%E2%80%94%E4%B8%8A/" rel="bookmark" title="「Scene Queries」AABBTree——上">「Scene Queries」AABBTree——上</a></li><li><a href="/learning/physx/%E3%80%8CScene%20Queries%E3%80%8DAABBTree%E2%80%94%E2%80%94%E4%B8%8B/" rel="bookmark" title="「Scene Queries」AABBTree——下">「Scene Queries」AABBTree——下</a></li><li class="active"><a href="/learning/physx/%E3%80%8CScene%20Queries%E3%80%8DAABBPruner/" rel="bookmark" title="「Scene Queries」AABBPruner">「Scene Queries」AABBPruner</a></li><li><a href="/learning/physx/Collision%E5%88%86%E4%BA%AB/" rel="bookmark" title="Collision分享">Collision分享</a></li><li><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Collision%E7%AF%87/" rel="bookmark" title="PhysX——Collision篇">PhysX——Collision篇</a></li><li><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Simulate%E7%AF%87/" rel="bookmark" title="PhysX——Simulate篇">PhysX——Simulate篇</a></li><li><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Task%20Management%E7%AF%87/" rel="bookmark" title="PhysX——Task Management篇">PhysX——Task Management篇</a></li><li><a href="/learning/physx/PhysX%E2%80%94%E2%80%94GJK%20&&%20EPA/" rel="bookmark" title="PhysX——GJK && EPA">PhysX——GJK && EPA</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="鑫酱(●'◡'●)" data-src="/images/avatar.jpg"><p class="name" itemprop="name">鑫酱(●'◡'●)</p><div class="description" itemprop="description">整天摸鱼，却妄想拯救世界的技术宅</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">100</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">24</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">53</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsbGVuR1g=" title="https:&#x2F;&#x2F;github.com&#x2F;AllenGX"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTgwNTM4MjQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;80538242"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjE0MTM5MDcxNTNAcXEuY29t" title="mailto:1413907153@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>好友</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>网址</a></li><li class="item"><a href="/travellings/" rel="section"><i class="ic i-paper-plane"></i>传送门</a></li><li class="item"><a href="/mikutap/" rel="section"><i class="ic i-star"></i>Mikutap</a></li><li class="item"><a href="/restart/" rel="section"><i class="ic i-sun"></i>RestartLife</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/learning/physx/%E3%80%8CScene%20Queries%E3%80%8DAABBTree%E2%80%94%E2%80%94%E4%B8%8B/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Simulate%E7%AF%87/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/" title="分类于 编程语言">编程语言</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/learning/programlanguage/cpp/%E5%8D%81%E5%85%AD%E3%80%81string%20%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/" title="十六、string 类和标准模板库">十六、string 类和标准模板库</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/algorithm/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/algorithm/findpath/" title="分类于 寻路">寻路</a></div><span><a href="/algorithm/findpath/A_star%E7%AE%97%E6%B3%95/" title="A_star算法">A_star算法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/physx/" title="分类于 物理引擎">物理引擎</a></div><span><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Memory%20Management%E7%AF%87/" title="PhysX——Memory Management篇">PhysX——Memory Management篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/" title="分类于 编程语言">编程语言</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/learning/programlanguage/cpp/%E5%8D%81%E4%BA%94%E3%80%81%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/" title="十五、友元、异常和其他">十五、友元、异常和其他</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/physx/" title="分类于 物理引擎">物理引擎</a></div><span><a href="/learning/physx/PhysX%E2%80%94%E2%80%94GJK%20&&%20EPA/" title="PhysX——GJK &amp;&amp; EPA">PhysX——GJK && EPA</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/" title="分类于 编程语言">编程语言</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/python/" title="分类于 python">python</a></div><span><a href="/learning/programlanguage/python/Python2-Yield-Async/" title="python2解决异步协程问题">python2解决异步协程问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game202/" title="分类于 GAME202高质量实时渲染">GAME202高质量实时渲染</a></div><span><a href="/learning/games/Game202/%E5%9B%9B%E3%80%81Real-time%20Global%20Illumination/" title="四、Real-time Global Illumination">四、Real-time Global Illumination</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/physx/" title="分类于 物理引擎">物理引擎</a></div><span><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Simulate%E7%AF%87/" title="PhysX——Simulate篇">PhysX——Simulate篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game202/" title="分类于 GAME202高质量实时渲染">GAME202高质量实时渲染</a></div><span><a href="/learning/games/Game202/%E4%BA%94%E3%80%81Real-time%20Physically-based%20Materials/" title="五、Real-time Physically-based Materials">五、Real-time Physically-based Materials</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game101/" title="分类于 Games101图形渲染">Games101图形渲染</a></div><span><a href="/learning/games/Game101/%E5%8D%81%E4%B8%80%E3%80%81Geometry%EF%BC%88%E4%B8%AD%EF%BC%89%E2%80%94%E2%80%94Curves/" title="十一、Geometry（中）——Curves">十一、Geometry（中）——Curves</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">鑫酱(●'◡'●) @ 个人博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">523k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">7:55</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"learning/physx/「Scene Queries」AABBPruner/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/animejs@3.2.0/lib/anime.min.js,npm/katex@0.12.0/dist/contrib/copy-tex.min.js,npm/frappe-charts@1.5.0/dist/frappe-charts.min.iife.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/quicklink@2/dist/quicklink.umd.js,gh/amehime/MiniValine@4.2.2-beta10/dist/MiniValine.min.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b6d809b500bd6f0040117088899bc7bf";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>