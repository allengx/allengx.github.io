<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="XqWEZ-KjvQT4IfXzxYvH-PEc--_zN6GqthY2jBsqOs4"><meta name="msvalidate.01" content="4E28E3FDD5912EBBB84869B17359650D"><meta name="baidu-site-verification" content="code-dwpSTDBLS2"><link rel="alternate" type="application/rss+xml" title="鑫酱" href="https://hakuya.me/rss.xml"><link rel="alternate" type="application/atom+xml" title="鑫酱" href="https://hakuya.me/atom.xml"><link rel="alternate" type="application/json" title="鑫酱" href="https://hakuya.me/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="UE5,ReplicationGraph"><link rel="canonical" href="https://hakuya.me/learning/unreal/Unreal%20Replication%20%E7%AF%87/"><title>Unreal ReplicationGraph 篇 - UE - 学习 | 个人博客 = 鑫酱 = 笔记本</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Unreal ReplicationGraph 篇</h1><div class="meta"><span class="item" title="创建时间：2023-11-20 14:24:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-20T14:24:00+08:00">2023-11-20</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>24k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>22 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">个人博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (20).jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (22).jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper_3.jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (5).jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (4).jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (1).jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learning/" itemprop="item" rel="index" title="分类于 学习"><span itemprop="name">学习</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learning/unreal/" itemprop="item" rel="index" title="分类于 UE"><span itemprop="name">UE</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hakuya.me/learning/unreal/Unreal%20Replication%20%E7%AF%87/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="鑫酱(●'◡'●)"><meta itemprop="description" content="笔记本, 整天摸鱼，却妄想拯救世界的技术宅"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鑫酱"></span><div class="body md" itemprop="articleBody"><div class="note info"></div><h1 id="unreal-replicationgraph-篇"><a class="anchor" href="#unreal-replicationgraph-篇">#</a> Unreal ReplicationGraph 篇</h1><h2 id="概述"><a class="anchor" href="#概述">#</a> 概述</h2><p>ReplicationGraph 作为 Unreal 引擎的核心功能，提供了多人游戏下的网络复制。为了适应不同游戏场景和特殊业务需求，ReplicationGraph 提供了一套可扩展可定制化的设计模板，通过抽象同步过程，把关联的 Actor 和 Connection 通过图的方式组织在一起，然后依据图的联通特性快速完成同步内容的收集、筛查、过滤，同时允许业务层基于视野网格、距离、敏感区块、重要性、时效性等方面定制化筛选策略。通过搭配组合各项策略可以更好的优化服务器对于同步的性能开销，降低开发者的开发门槛，最终实现高效且灵活的同步机制。下面就来介绍一下 Unreal5.2 版本下的 ReplicationGraph 同步框架的整体结构：</p><h2 id="基本概念"><a class="anchor" href="#基本概念">#</a> 基本概念</h2><p>在了解 ReplicationGraph 结构之前，先来认识一些 ReplicationGraph 中的基本概念：</p><ul><li>每个客户端和服务器建立连接后，会创建对应的 Connection，一个 Connection 可能会有多个 ChildConnection（例如某些游戏支持在一台客户端上进行双人或多人对战的场景下）。因此一个 Connection 会关联至少一个 Actor。</li><li>不论是 ChildConnection 还是 Connection，都会通过 Viewer 用来代表观察者（通常是 PlayerController），同时还有一个 ViewTarget（通常是 Pawn）。<ul><li>PlayerController 用来接受玩家输入的服务器抽象。</li><li>Pawn 表示客户端对象在服务器上的实体（角色）。</li></ul></li><li>所有参与同步的对象都是 <strong>AActor</strong> 或者 <strong>AActor</strong> 派生类，且每个 <strong>AActor</strong> 同步到 Connection 时，都会建立对应的 <strong>ActorChannel</strong>。</li><li>权威性。这个名字比较抽象，可以简单理解为对当前对象（角色）的掌控权力：<ul><li>ROLE_SimulatedProxy：有话语权，但没有操作权。能对自己的角色指手画脚，听不听话还得看别人脸色。</li><li>ROLE_AutonomousProxy：屁都不能放一个，别人说啥就是啥。</li><li>ROLE_Authority：操作权。啥事都得听我的，我就是这个世界的卡密。</li><li>通常情况下服务器会拥有所有对象的「操作权」，客户端会拥有自己控制角色的「话语权」。</li></ul></li></ul><h2 id="数据组成"><a class="anchor" href="#数据组成">#</a> 数据组成</h2><p>最先介绍的是数据部分。由于数据贯穿整个同步流程中，经常被开发者所念叨的就是：“什么时候，哪些对象，同步哪些数据”。我想这也是整个复制框架一直在考虑的问题。ReplicationGraph 把这些问题，通过各项约束进行建模并形成一套完善的衡量体系，抽离出多个评估指标：</p><ul><li>同步周期</li><li>基于类型的同步优先级</li><li>饥饿因子</li><li>距离因子</li><li>剔除距离</li><li>数据状态（Awake、Dormancy、TearOff...）</li><li>快捷通道（FastShared）</li><li>连接带宽</li></ul><p>其中的数据又可以分为两个大类：</p><ul><li>纯配置数据（不可变）</li><li>运行时数据（可变）</li></ul><p>事不宜迟，接下来就从这些数据入手，看看 ReplicationGraph 如何组织这些数据的。弄清楚这些，整个 ReplicationGraph 的实现也就非常明了了：</p><h3 id="actor类全局数据classmap纯配置数据"><a class="anchor" href="#actor类全局数据classmap纯配置数据">#</a> Actor 类全局数据「ClassMap」（纯配置数据）</h3><p>ReplicationGraph 提供了基于 Actor 类型的定制策略，允许基于不同的 Actor 类型定制对应的同步策略。例如某些对象非常庞大，不论身处世界的哪个角落都能看见，那么「剔除距离」就可以设置为 0（无穷大）。又比如某些对象经常变化，且客户端对于这种变化感知需要非常敏感，那么就可以缩减这些对象的「同步周期」。</p><h3 id="actor类实例特化数据actormap配置运行时数据"><a class="anchor" href="#actor类实例特化数据actormap配置运行时数据">#</a> Actor 类实例特化数据「ActorMap」（配置 &amp;&amp; 运行时数据）</h3><p>ActorMap 主要记录现有 Actor 实例的一些设置，部分来源于 ClassMap 的配置数据，还有一些是运行中产生的。比如有一些 Npc 创建出来后，附近有玩家时，会被激活（Dormancy -&gt; Awake），那么在未激活情况下就不需要频繁同步。亦或者一些角色可以根据自己的装备特性让别的玩家看不见，那么就可以设置 TearOff 从而达到暂时隐身的效果。</p><h3 id="connection类实例中各个actor实例数据actorinfomap运行时数据"><a class="anchor" href="#connection类实例中各个actor实例数据actorinfomap运行时数据">#</a> Connection 类实例中各个 Actor 实例数据「ActorInfoMap」（运行时数据）</h3><p>由于 Actor 会根据需要同步给任意数量的 Connection。因此针对每个 Connection 单独记录一个同步设置也是必不可少的。比如一个 Actor 我可以看见但其他人就是看不到，那么就可以单独在我的 Connection 内设置可见性。而且不同 Connection 的同步周期也不是一致的，因此单独记录是十分有必要哒。</p><h3 id="小总结"><a class="anchor" href="#小总结">#</a> 小总结</h3><p>这里做个简单总结：</p><ul><li>全局控制器：ReplicationGraph 通过 CDO 的默认设置，为全局的同步提供默认解决方案。</li><li>类的全局控制器：ReplicationGraph 通过对所有 Actor 类型提供定制的功能（ClassMap），比如某类物体同步快一些，又或者某类同步范围大一些。来控制该类对象的所有同步行为。</li><li>对象的全局控制器：ReplicationGraph 针对单个 Actor 实例通过控制其同步状态等（ActorMap），影响其在所有 Connection 的同步策略。</li><li>连接的控制器：ReplicationGraph 针对任意 Conntion 定制策略。影响某个或某些连接的同步规则（主要是限流）。</li><li>点对点的控制器：ReplicationGraph 针对任意 Conntion 中 Actor 的定制策略（ActorInfoMap）。影响点对点的同步模式。</li></ul><h2 id="三剑客"><a class="anchor" href="#三剑客">#</a> 三剑客</h2><p>说完核心的数据部分，接下来就轮到负责承载和处理这些数据的「三剑客」，也是构筑起整个同步框架的核心类：</p><ul><li>UReplicationGraph</li><li>UNetReplicationGraphConnection</li><li>UReplicationGraphNode</li></ul><h3 id="ureplicationgraph"><a class="anchor" href="#ureplicationgraph">#</a> UReplicationGraph</h3><p>话不多说，先上类图：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/UReplicationGraph.png" alt="UReplicationGraph"></p><p><strong>UReplicationGraph</strong> 继承自 <strong>UReplicationDriver</strong>。<strong>UReplicationDriver</strong> 中定义了贯穿整个同步系统的接口，对任何数据的操作都可以在 <strong>UReplicationDriver</strong> 中找到合适的接口，集百家所长，这也是 <strong>UReplicationGraph</strong> 功能丰富的原因之一。由于 <strong>UReplicationGraph</strong> 和 <strong>NetDriver</strong> 直接关联，而一个 <strong>NetDriver</strong> 只能绑定一个 <strong>World</strong>，<strong>UReplicationGraph</strong> 的复制体系本质上是建立在 <strong>World</strong> 内的。既然如此，之前提到的一些全局性质的数据存放于此也再合适不过 ——ClassMap &amp;&amp; ActorMap。</p><p>除此以外，<strong>UReplicationGraph</strong> 还承担了 UNetReplicationGraphConnection 的管理工作，负责透传各项传操作给 UNetReplicationGraphConnection。</p><h4 id="深入了解-classmap-actormap"><a class="anchor" href="#深入了解-classmap-actormap">#</a> 深入了解 ClassMap &amp;&amp; ActorMap</h4><p>在 <code>UReplicationGraph::InitGlobalActorClassSettings</code> 初始化的时候 <strong>ClassMap</strong> 也随之一起初始化，这两个类的数据都是通过若干个 <strong>FClassReplicationInfo</strong> 组成：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">UReplicationGraph</span><span class="token operator">::</span><span class="token function">InitGlobalActorClassSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token comment">// AInfo and APlayerControllers have no world location, so distance scaling should always be 0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	FClassReplicationInfo NonSpatialClassInfo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	NonSpatialClassInfo<span class="token punctuation">.</span>DistancePriorityScale <span class="token operator">=</span> <span class="token number">0.f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>	GlobalActorReplicationInfoMap<span class="token punctuation">.</span><span class="token function">SetClassInfo</span><span class="token punctuation">(</span> <span class="token class-name">AInfo</span><span class="token operator">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NonSpatialClassInfo <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	GlobalActorReplicationInfoMap<span class="token punctuation">.</span><span class="token function">SetClassInfo</span><span class="token punctuation">(</span> <span class="token class-name">APlayerController</span><span class="token operator">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> NonSpatialClassInfo <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token comment">// ...</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>ActorMap</strong> 的初始化伴随则整个游戏周期，在 Actor 创建、销毁、状态切换等时机都会进行更新。同时也是用来评估 Actor 同步的重要数据源。此外 <strong>ActorMap</strong> 中还保存了有关 Actor 之间的依赖关系（部分 Actor 之前存在从属关系，父类同步的情况下，下属也需要连带同步）</p><p>从类图中可以看到各项指标的定义都在 <strong>FClassReplicationInfo</strong> 中。Actor 的动态数据则存在于 <strong>FGlobalActorReplicationInfo</strong> 中。</p><h3 id="unetreplicationgraphconnection"><a class="anchor" href="#unetreplicationgraphconnection">#</a> UNetReplicationGraphConnection</h3><p><strong>UNetReplicationGraphConnection</strong> 在设计上对标了 <strong>UNetConnection</strong>。如果说 UReplicationGraph 是管全局的，那么 <strong>UNetReplicationGraphConnection</strong> 则主要负责管理单个连接，先来看看类图：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/UNetReplicationGraphConnection.png" alt="UNetReplicationGraphConnection"></p><p><strong>UNetReplicationGraphConnection</strong> 也继承了一个接口类 ——<strong>UReplicationConnectionDriver</strong>。目的也是类似的，主要是用来规范接口标准，保证操作能够透传遍整条链路。</p><h4 id="深入了解-actorinfomap"><a class="anchor" href="#深入了解-actorinfomap">#</a> 深入了解 ActorInfoMap</h4><p>作为 UNetConnection 在同步层的抽象，而 <strong>ActorInfoMap</strong> 又是记录 Connection 相关数据的，因此由 <strong>UNetReplicationGraphConnection</strong> 内部来维护 <strong>ActorInfoMap</strong> 再合适不过。</p><p><strong>ActorInfoMap</strong> 内部主要由三个部分组成：</p><ul><li>GlobalMap：这里引用了的 UReplicationGraph 的 ActorMap &amp;&amp; ClassMap，方便读取。</li><li>ActorMap &amp;&amp; ChannelMap：这两个结构也就是上面提到的 ActorInfoMap 。两个结构存放的内容非常相似，都是 Connection 中同步过的 Actor 的信息，一个是依据 Actor 为 key，一个是依据 Actor 的 Channel 为 key。两者区别主要是 Actor 的生命周期更长一些，如果 Actor 进入 Dormancy 状态时，Channel 会关闭，此时 Channel 的映射可能会移除，而 Actor 映射则是在 Actor 真正销毁的时候才会移除。使用两个 map 存储还有一点是方便不同的 key 进行查询。</li></ul><h4 id="优化策略初见端倪"><a class="anchor" href="#优化策略初见端倪">#</a> 优化策略初见端倪</h4><p>可以看见 <strong>UNetReplicationGraphConnection</strong> 已经有一些 <strong>UReplicationGraphNode</strong> 的成员定义及相关数据了（绿色部分）：</p><ul><li>存放历史 Dormancy 状态 Actors 的 <strong>PrevDormantActorListPerNode</strong>。</li><li>存放 GridNode 中可以被 Viewers 看见的 Cell——<strong>NodesVisibleCells</strong>。</li><li>处理 TearOff 相关逻辑的 TearOffNode。</li></ul><p>对于这些优化策略，暂且按下不表，将会在后面的 UReplicationGraphNode 处展开讲解。</p><h4 id="销毁对象的处理"><a class="anchor" href="#销毁对象的处理">#</a> 销毁对象的处理</h4><p><strong>UNetReplicationGraphConnection</strong> 中花费了较多的逻辑来处理 <strong>ActorDestruction</strong> 的相关内容。</p><p><strong>ActorDestruction</strong> 实际上是用来记录 Actor 销毁前的残留信息，其中包括 Actor 销毁时的坐标、所在流式关卡名称等信息。存储下来主要是为了能够确保销毁可以被正确同步，因为 Actor 销毁后对象就不复存在了，如果在该时刻客户端没有收到销毁信息，之后将没有途径获取销毁的具体信息。</p><p>销毁信息主要分为两类 DestructInfo &amp;&amp; DormantDestructInfo：</p><ul><li>DormantDestructInfo：表示由于 Actor 进入休眠状态，直接视作销毁。这种方式销毁下 Connection 会同步给客户端一个休眠销毁信息，并且尝试关闭对应 Actor 的 Channel。</li><li>DestructInfo：非休眠状态下的销毁信息。这部分信息会根据 Viewers 和被销毁对象的位置进行同步。触发同步时通过对比上次触发时所处位置和当前位置是否超过某个阈值，如果超过的情况下会基于 DistanceCulling 判断被销毁物体距离是否可见。</li></ul><h3 id="ureplicationgraphnode"><a class="anchor" href="#ureplicationgraphnode">#</a> UReplicationGraphNode</h3><p><strong>UReplicationGraphNode</strong> 主要充当要被同步 Actor 的容器，同时配合上层策略完成收集工作。</p><ul><li><strong>UReplicationGraphNode_ActorListFrequencyBuckets</strong>、<strong>UReplicationGraphNode_ActorList</strong> 及其派生类作为容器负责存储 Actor，并提供一些筛选策略。</li><li>其他 <strong>UReplicationGraphNode</strong> 则仅仅只提供策略，不存储 Actor。</li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/UReplicationGraphNode.png" alt="UReplicationGraphNode"></p><p>得益于 <strong>UReplicationGraphNode</strong> 本身的结构和接口的定义。可以演化出不同的同步策略，并且可以互相搭配实现复杂的同步机制。目前官方提供了 5 种基础策略：</p><ul><li>UReplicationGraphNode_GridSpatialization2D：网格划分的同步策略。</li><li>UReplicationGraphNode_AlwaysRelevant &amp;&amp; UReplicationGraphNode_AlwaysRelevant_ForConnection：始终可见的全局同步策略。</li><li>UReplicationGraphNode_TearOff_ForConnection：针对 Connection 的定向擦除策略。</li><li>UReplicationGraphNode_DormancyNode &amp;&amp; UReplicationGraphNode_ConnectionDormancyNode：休眠唤醒策略。</li><li>UReplicationGraphNode_DynamicSpatialFrequency：动态空间频率策略。</li></ul><h4 id="ureplicationgraphnode_actorlist"><a class="anchor" href="#ureplicationgraphnode_actorlist">#</a> <strong>UReplicationGraphNode_ActorList</strong></h4><p>Actor 的容器结构，里面主要是分为两部分：</p><ul><li>StreamingLevelCollection：通过流式关卡名称来分别记录 Actor</li><li>ReplicationActorList：记录非流式关卡内的 Actor</li></ul><h4 id="ureplicationgraphnode_gridspatialization2d"><a class="anchor" href="#ureplicationgraphnode_gridspatialization2d">#</a> UReplicationGraphNode_GridSpatialization2D</h4><p><strong>UReplicationGraphNode_GridSpatialization2D</strong> 是一种比较常见的网格划分策略，需要搭配 <strong>UReplicationGraphNode_GridCell</strong> 一起使用。通过定义单个网格大小，将世界区域切分为多个 Cell，按照 Cell 为单位进行对象的同步。</p><p>具体流程：</p><ul><li>每次触发同步操作的时候，需要执行 <strong>PrepareForReplication()</strong> 对所有 Actor 进行 Cell 信息的更新。</li><li>然后把对应的 Actor 放置在所属的 <strong>UReplicationGraphNode_GridCell</strong> 内，一个 Actor 可能存在于多个 Cell 内。</li><li>当某个 Connection 需要获取同步 Actor 列表的时候，会先计算出该 Connection 中的 Viewer 对于哪些 Cell 可见，然后查询这些 Cell 来收集同步对象。</li><li>最后基于各项指标评估是否可以被同步，然后同步给客户端。</li></ul><h4 id="ureplicationgraphnode_alwaysrelevant"><a class="anchor" href="#ureplicationgraphnode_alwaysrelevant">#</a> UReplicationGraphNode_AlwaysRelevant</h4><p><strong>UReplicationGraphNode_AlwaysRelevant</strong> 相对比较简单，其内部提供了设置永远可见的类型。</p><p>具体流程：</p><ul><li>每次触发同步操作的时候，需要执行 <strong>PrepareForReplication()</strong> 对所有永远可见的类型的 Actor 挑选出来，加入到 ChildNode。</li><li>在 GatherActorListsForConnection 操作的时候无脑全量提取即可。</li></ul><blockquote><p>这个设计导致很多地方为了实现 AlwaysRelevant 都单独写了 Update 机制来替换 PrepareForReplication。</p></blockquote><h4 id="ureplicationgraphnode_alwaysrelevant_forconnection"><a class="anchor" href="#ureplicationgraphnode_alwaysrelevant_forconnection">#</a> UReplicationGraphNode_AlwaysRelevant_ForConnection</h4><p>也是永久可见策略，但是基于 Connection。</p><p>内部会记录对于该 Connection 永久可见的 Actor，同时 Connection 中有关该 Actor 的距离剔除信息（ActorInfoMap）会被设置为 0，就可以不被距离策略给过滤掉。</p><h4 id="ureplicationgraphnode_tearoff_forconnection"><a class="anchor" href="#ureplicationgraphnode_tearoff_forconnection">#</a> UReplicationGraphNode_TearOff_ForConnection</h4><p><strong>UReplicationGraphNode_TearOff_ForConnection</strong> 像是 UReplicationGraphNode_AlwaysRelevant_ForConnection 的对立。内部记录了某个 Actor 将要在该 Connection 内被擦除的帧数。</p><h4 id="ureplicationgraphnode_dormancynode"><a class="anchor" href="#ureplicationgraphnode_dormancynode">#</a> UReplicationGraphNode_DormancyNode</h4><p>用来管理 <strong>UReplicationGraphNode_ConnectionDormancyNode</strong>，自己不干什么活。主要是存储休眠了的 Actor（Actor 本身休眠而不是针对某个连接休眠）。</p><p>大部分接口都是通过 <strong>UReplicationGraphNode_GridSpatialization2D</strong> 或者更上层的 <strong>UReplicationGraph</strong> 进行调用，然后负责传达给下层的 <strong>UReplicationGraphNode_ConnectionDormancyNode</strong>。</p><h4 id="ureplicationgraphnode_connectiondormancynode"><a class="anchor" href="#ureplicationgraphnode_connectiondormancynode">#</a> UReplicationGraphNode_ConnectionDormancyNode</h4><p>用来管理 Connection 所关联的休眠 Actor，实现上高度依赖 <strong>UReplicationGraphNode_GridCell</strong>，大部分休眠节点来源于流式关卡的显隐状态切换导致。少部分通过上层业务主动调用。Actor 基于 Connection 的休眠流程如下：</p><ul><li>基于某种原因触发 Actor 的状态切换（唤醒 -&gt; 休眠）</li><li>体现在各个 Connection 中表现为：<ul><li>休眠节点加入 Connection 的 PendingDormantDestructList。</li><li>重新设置为<strong>唤醒</strong>状态 ——NotifyActorDormancyFlush（强制唤醒 Actor）</li><li>同步 <strong>DormantDestructInfo</strong> 信息，让 Actor 走休眠销毁流程（这里对象必须处于唤醒状态，不然无法正常同步销毁信息）</li><li>收到（客户端）销毁信息，设置 Actor 为休眠状态。关闭 Connection 中对应 Actor 的 Channel。</li><li>收到（服务器）Channel 关闭，设置 Actor 为休眠状态。Actor 正式进入休眠。</li></ul></li></ul><p>整体实现还是不太好理解的，有兴趣可以去看看具体实现：</p><ul><li><code>UNetReplicationGraphConnection::ReplicateDormantDestructionInfos</code> 部分。</li><li><code>UReplicationGraphNode_GridSpatialization2D::GatherActorListsForConnection</code> 的 PrevDormantActorList 处理部分。</li><li><code>UControlChannel::ReceiveDestructionInfo</code> 的 <code>CloseReason == EChannelCloseReason::Dormancy</code> 部分。</li><li><code>UActorChannel::Close(EChannelCloseReason Reason</code> 的 <code>Reason == EChannelCloseReason::Dormancy</code> 部分。</li></ul><h4 id="ureplicationgraphnode_dynamicspatialfrequency"><a class="anchor" href="#ureplicationgraphnode_dynamicspatialfrequency">#</a> UReplicationGraphNode_DynamicSpatialFrequency</h4><p><strong>DynamicSpatialFrequency</strong> 思想主要来源于人类视觉系统对于不同方向和空间频率的敏感度存在「方向选择性」和「空间频率选择性」。基于这种特性就可以简单对视野范围内不同方位做不同频率的更新，从而在不影响体验的情况下优化性能。</p><p>其中的实现还是比较复杂的，需要根据法线方向划分周围区域到多个 Zone。然后根据 Actor 处于 Viewer 的某个 Zone，来决定其下次的更新时机。算是在更新周期上下了一番功夫，可能对于单次同步开销高昂的对象有不错的效果。</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20231117220403256.png" alt="image-20231117220403256" width="300px"></p><h3 id="小总结-2"><a class="anchor" href="#小总结-2">#</a> 小总结</h3><p>本节主要介绍了 5 种优化策略。有关 ReplicationGraph 如何组织数据以及如何用各种策略优化同步的方式，到此也有了一个基本认识。</p><p>ReplicationGraph 提供了基于 <strong>UReplicationGraphNode_GridSpatialization2D</strong> 的划分结构，在每个 <strong>UReplicationGraphNode_GridCell</strong> 内又提供了两种默认的优化策略 ——<strong>UReplicationGraphNode_DormancyNode</strong> &amp;&amp; <strong>UReplicationGraphNode_ActorListFrequencyBuckets</strong>。</p><p><strong>UReplicationGraphNode_DormancyNode</strong> 用来处理休眠对象，保证对象休眠后尽可能的减少同步开销。<strong>UReplicationGraphNode_ActorListFrequencyBuckets</strong> 对非休眠对象的同步检查进行分帧处理，保证性能的稳定。</p><p>除此以外，还提供了 <strong>UReplicationGraphNode_AlwaysRelevant_ForConnection</strong> &amp;&amp; <strong>UReplicationGraphNode_TearOff_ForConnection</strong> 来处理 Connection 层面的可见和擦除。</p><p>这些基本策略都是默认包含的，只要采用了 <strong>UBasicReplicationGraph</strong> 就可以立马生效，此外还可以尝试一下 <strong>UReplicationGraphNode_DynamicSpatialFrequency</strong> 的优化，或许也会有意想不到的效果。</p><p>下面是 <strong>UBasicReplicationGraph</strong> 内的大致同步策略图：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/UBasicReplicationGraph.png" alt="UBasicReplicationGraph"></p><h2 id="如何知道哪些对象需要同步"><a class="anchor" href="#如何知道哪些对象需要同步">#</a> 如何知道哪些对象需要同步？</h2><p>这个问题要说简单也简单，要说复杂也复杂。大部分情况下 GraphNode 中收集到的 Actor 都是需要同步的。这里需要依赖 Actor 的管理策略了，也就是上述 5 种策略如何搭配组合。这将决定每次执行 <code>GatherActorListsForConnection</code> 获取到需要同步的 ActorList 的结果。</p><p>但最终哪些会被同步还是取决于 <code>ReplicateActorListsForConnections_Default</code> &amp;&amp; <code>ReplicateActorListsForConnections_FastShared</code> 。</p><ul><li><strong>ReplicateActorListsForConnections_Default</strong> 会根据对象的各项权重计算出最终的因子。由于带宽资源有限，基于权重因子的排序的结果会觉定哪些对象更「重要」，从而更容易获得同步资格。</li><li><strong>ReplicateActorListsForConnections_FastShared</strong> 和 Default 是两个分开的赛道，这里面的对象走的是绿通，不需要考虑优先级，因此唯一的筛选标准只有「裁剪距离」。但是同样有自己的带宽限制，因此不可能全同步，公平期间采用的是分帧处理。</li></ul><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>int32 ListIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ListIdx <span class="token operator">&lt;</span> GatheredLists<span class="token punctuation">.</span><span class="token function">Num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>ListIdx<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">const</span> FActorRepListConstView<span class="token operator">&amp;</span> List <span class="token operator">=</span> GatheredLists<span class="token punctuation">[</span><span class="token punctuation">(</span>ListIdx <span class="token operator">+</span> FrameNum<span class="token punctuation">)</span> <span class="token operator">%</span> GatheredLists<span class="token punctuation">.</span><span class="token function">Num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int32 i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> List<span class="token punctuation">.</span><span class="token function">Num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">//... 这里用帧率对 GatheredLists 求余来做起始点的随机</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>下面简单梳理了一下同步的流程图：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/ServerReplicateActors.png" alt="ServerReplicateActors"></p><h2 id="其他特性"><a class="anchor" href="#其他特性">#</a> 其他特性</h2><h3 id="default-fastshared"><a class="anchor" href="#default-fastshared">#</a> Default &amp;&amp; FastShared</h3><p>这个上面也简单介绍了， <code>GatherActorListsForConnection</code> 里面有两种类型 Actor 的收集，一种是走正常同步，另一种则是快捷通道的同步。如果需要体验这种 FastShared，需要提前在 <strong>FGlobalActorReplicationInfo</strong> 中注册同步函数 <code>FastSharedReplicationFunc</code> ，该函数是针对 Actor 对象级别的处理。例如同步玩家的位置信息：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>CharacterClassRepInfo<span class="token punctuation">.</span>FastSharedReplicationFunc <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>AActor<span class="token operator">*</span> Actor<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">bool</span> bSuccess <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>ALyraCharacter<span class="token operator">*</span> Character <span class="token operator">=</span> Cast<span class="token operator">&lt;</span>ALyraCharacter<span class="token operator">></span><span class="token punctuation">(</span>Actor<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>		bSuccess <span class="token operator">=</span> Character<span class="token operator">-></span><span class="token function">UpdateSharedReplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">return</span> bSuccess<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">bool</span> <span class="token class-name">ALyraCharacter</span><span class="token operator">::</span><span class="token function">UpdateSharedReplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">GetLocalRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ROLE_Authority<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>		FSharedRepMovement SharedMovement<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>SharedMovement<span class="token punctuation">.</span><span class="token function">FillForCharacter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>			<span class="token comment">// Only call FastSharedReplication if data has changed since the last frame.</span></pre></td></tr><tr><td data-num="19"></td><td><pre>			<span class="token comment">// Skipping this call will cause replication to reuse the same bunch that we previously</span></pre></td></tr><tr><td data-num="20"></td><td><pre>			<span class="token comment">// produced, but not send it to clients that already received. (But a new client who has not received</span></pre></td></tr><tr><td data-num="21"></td><td><pre>			<span class="token comment">// it, will get it this frame)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>SharedMovement<span class="token punctuation">.</span><span class="token function">Equals</span><span class="token punctuation">(</span>LastSharedReplication<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>			<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>				LastSharedReplication <span class="token operator">=</span> SharedMovement<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>				ReplicatedMovementMode <span class="token operator">=</span> SharedMovement<span class="token punctuation">.</span>RepMovementMode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>				<span class="token function">FastSharedReplication</span><span class="token punctuation">(</span>SharedMovement<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>	<span class="token comment">// We cannot fastrep right now. Don't send anything.</span></pre></td></tr><tr><td data-num="34"></td><td><pre>	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="replayconnection"><a class="anchor" href="#replayconnection">#</a> ReplayConnection</h3><p>回放连接，该连接特点在于 <code>GatherActorListsForConnection</code> 收集 Actor 的时候，可以共享所有 Connection Viewers 的视野进行 Actor 收集，有点类似全图视野的感觉。</p><h3 id="swaproles"><a class="anchor" href="#swaproles">#</a> SwapRoles</h3><p>SwapRoles 功能是可以<strong>永久</strong>切换 Actor 的权威性，可以让原本受服务器控制的 Npc 交给客户端管理，服务器充当被同步方。</p><p>这里为了保证客户端获取到权威性后，服务器能够正常把修改同步给其他客户端。一般会创建一个哨兵对象：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>TOptional<span class="token operator">&lt;</span>FScopedActorRoleSwap<span class="token operator">></span> SwapGuard</pre></td></tr></table></figure><p>在客户端执行完操作并同步给服务器完成数据的复制以后，服务器会切换回权威状态，并处理同步操作给到其他客户端，由于这种调换是基于 Connection 的，因此其他客户端连接中不会发生权威性的互换操作，可以正常通过网络复制被同步。</p><h2 id="定制化案例-lyra"><a class="anchor" href="#定制化案例-lyra">#</a> 定制化案例 Lyra</h2><p>说了这么多，那具体如何上手呢？这里通过 Lyra 案例进行简单的介绍。LyraGame 中主要是定制了 ULyraReplicationGraph、ULyraReplicationGraphNode_AlwaysRelevant_ForConnection 并实现了另类的分帧策略 ULyraReplicationGraphNode_PlayerStateFrequencyLimiter。</p><h3 id="ulyrareplicationgraph"><a class="anchor" href="#ulyrareplicationgraph">#</a> ULyraReplicationGraph</h3><p>先来看看 ULyraReplicationGraph，这里比较关键的是 <strong>InitGlobalActorClassSettings</strong> 实现：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">ULyraReplicationGraph</span><span class="token operator">::</span><span class="token function">InitGlobalActorClassSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token comment">// 注册了 Class Init 的函数，里面夹带了 RegisterClassRepNodeMapping 操作</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	GlobalActorReplicationInfoMap<span class="token punctuation">.</span><span class="token function">SetInitClassInfoFunc</span><span class="token punctuation">(</span><span class="token comment">/*....*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token comment">// 注册了对象初始化函数，主要是为了获取 Route 策略</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	ClassRepNodePolicies<span class="token punctuation">.</span>InitNewElement <span class="token operator">=</span> <span class="token comment">/*....*/</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token comment">// 一些 Lyra 配置的路由策略类</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> FRepGraphActorClassSettings<span class="token operator">&amp;</span> ActorClassSettings <span class="token operator">:</span> LyraRepGraphSettings<span class="token operator">-></span>ClassSettings<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>ActorClassSettings<span class="token punctuation">.</span>bAddClassRepInfoToMap<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>			<span class="token keyword">if</span> <span class="token punctuation">(</span>UClass<span class="token operator">*</span> StaticActorClass <span class="token operator">=</span> ActorClassSettings<span class="token punctuation">.</span><span class="token function">GetStaticActorClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>			<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>				<span class="token function">AddClassRepInfo</span><span class="token punctuation">(</span>StaticActorClass<span class="token punctuation">,</span> ActorClassSettings<span class="token punctuation">.</span>ClassNodeMapping<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 这里遍历了所有 UClass 类，把能够同步的记录下来，并设置对应的 Route 策略。</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">// 该策略是 Lyra 定制的，用于指定哪些类型可以被放入到哪些 GraphNode 中</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	TArray<span class="token operator">&lt;</span>UClass<span class="token operator">*</span><span class="token operator">></span> AllReplicatedClasses<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>TObjectIterator<span class="token operator">&lt;</span>UClass<span class="token operator">></span> It<span class="token punctuation">;</span> It<span class="token punctuation">;</span> <span class="token operator">++</span>It<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">//....</span></pre></td></tr><tr><td data-num="26"></td><td><pre>		AllReplicatedClasses<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Class<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>		<span class="token function">RegisterClassRepNodeMapping</span><span class="token punctuation">(</span>Class<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>	<span class="token comment">// 设置了一下 ACharacter 各项权重因子</span></pre></td></tr><tr><td data-num="32"></td><td><pre>	<span class="token keyword">auto</span> SetClassInfo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span>UClass<span class="token operator">*</span> Class<span class="token punctuation">,</span> <span class="token keyword">const</span> FClassReplicationInfo<span class="token operator">&amp;</span> Info<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> GlobalActorReplicationInfoMap<span class="token punctuation">.</span><span class="token function">SetClassInfo</span><span class="token punctuation">(</span>Class<span class="token punctuation">,</span> Info<span class="token punctuation">)</span><span class="token punctuation">;</span> ExplicitlySetClasses<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Class<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>	ExplicitlySetClasses<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>	FClassReplicationInfo CharacterClassRepInfo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	CharacterClassRepInfo<span class="token punctuation">.</span>DistancePriorityScale <span class="token operator">=</span> <span class="token number">1.f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	CharacterClassRepInfo<span class="token punctuation">.</span>StarvationPriorityScale <span class="token operator">=</span> <span class="token number">1.f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	CharacterClassRepInfo<span class="token punctuation">.</span>ActorChannelFrameTimeout <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>	CharacterClassRepInfo<span class="token punctuation">.</span><span class="token function">SetCullDistanceSquared</span><span class="token punctuation">(</span><span class="token class-name">ALyraCharacter</span><span class="token operator">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>GetDefaultObject<span class="token operator">&lt;</span>ALyraCharacter<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>NetCullDistanceSquared<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>	<span class="token function">SetClassInfo</span><span class="token punctuation">(</span><span class="token class-name">ACharacter</span><span class="token operator">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CharacterClassRepInfo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre>	<span class="token comment">// 设置了一下 ALyraCharacter 的 FastShared 同步函数处理，以及 FastShared 自身通道的相关配置</span></pre></td></tr><tr><td data-num="42"></td><td><pre>	CharacterClassRepInfo<span class="token punctuation">.</span>FastSharedReplicationFunc <span class="token operator">=</span> <span class="token comment">/*....*/</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>	CharacterClassRepInfo<span class="token punctuation">.</span>FastSharedReplicationFuncName <span class="token operator">=</span> <span class="token function">FName</span><span class="token punctuation">(</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"FastSharedReplication"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>	FastSharedPathConstants<span class="token punctuation">.</span>MaxBitsPerFrame <span class="token operator">=</span> <span class="token punctuation">(</span>int32<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Lyra<span class="token operator">::</span>RepGraph<span class="token operator">::</span>TargetKBytesSecFastSharedPath <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">/</span> NetDriver<span class="token operator">-></span>NetServerMaxTickRate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>	FastSharedPathConstants<span class="token punctuation">.</span>DistanceRequirementPct <span class="token operator">=</span> Lyra<span class="token operator">::</span>RepGraph<span class="token operator">::</span>FastSharedPathCullDistPct<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>	<span class="token function">SetClassInfo</span><span class="token punctuation">(</span><span class="token class-name">ALyraCharacter</span><span class="token operator">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CharacterClassRepInfo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre></pre></td></tr><tr><td data-num="48"></td><td><pre>	<span class="token comment">// 设置了一下分帧策略，因为 UReplicationGraphNode_GridCell 会用到</span></pre></td></tr><tr><td data-num="49"></td><td><pre>	UReplicationGraphNode_ActorListFrequencyBuckets<span class="token operator">::</span>DefaultSettings<span class="token punctuation">.</span>ListSize <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>	UReplicationGraphNode_ActorListFrequencyBuckets<span class="token operator">::</span>DefaultSettings<span class="token punctuation">.</span>NumBuckets <span class="token operator">=</span> Lyra<span class="token operator">::</span>RepGraph<span class="token operator">::</span>DynamicActorFrequencyBuckets<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>	UReplicationGraphNode_ActorListFrequencyBuckets<span class="token operator">::</span>DefaultSettings<span class="token punctuation">.</span>BucketThresholds<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>	UReplicationGraphNode_ActorListFrequencyBuckets<span class="token operator">::</span>DefaultSettings<span class="token punctuation">.</span>EnableFastPath <span class="token operator">=</span> <span class="token punctuation">(</span>Lyra<span class="token operator">::</span>RepGraph<span class="token operator">::</span>EnableFastSharedPath <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>	UReplicationGraphNode_ActorListFrequencyBuckets<span class="token operator">::</span>DefaultSettings<span class="token punctuation">.</span>FastPathFrameModulo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre></pre></td></tr><tr><td data-num="55"></td><td><pre>    <span class="token comment">// 初始化 RPC 相关准入策略</span></pre></td></tr><tr><td data-num="56"></td><td><pre>	RPCSendPolicyMap<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>UClass<span class="token operator">*</span> ReplicatedClass <span class="token operator">:</span> AllReplicatedClasses<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="58"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>		<span class="token function">RegisterClassReplicationInfo</span><span class="token punctuation">(</span>ReplicatedClass<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="61"></td><td><pre></pre></td></tr><tr><td data-num="62"></td><td><pre>	<span class="token comment">// 初始化 DestructInfo 最远距离</span></pre></td></tr><tr><td data-num="63"></td><td><pre>	DestructInfoMaxDistanceSquared <span class="token operator">=</span> Lyra<span class="token operator">::</span>RepGraph<span class="token operator">::</span>DestructionInfoMaxDist <span class="token operator">*</span> Lyra<span class="token operator">::</span>RepGraph<span class="token operator">::</span>DestructionInfoMaxDist<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="64"></td><td><pre></pre></td></tr><tr><td data-num="65"></td><td><pre>	<span class="token comment">// 初始化 RPC multicasts 广播策略</span></pre></td></tr><tr><td data-num="66"></td><td><pre>	RPC_Multicast_OpenChannelForClass<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="67"></td><td><pre>	RPC_Multicast_OpenChannelForClass<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token class-name">AActor</span><span class="token operator">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Open channels for multicast RPCs by default</span></pre></td></tr><tr><td data-num="68"></td><td><pre>	RPC_Multicast_OpenChannelForClass<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token class-name">AController</span><span class="token operator">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// multicasts should never open channels on Controllers since opening a channel on a non-owner breaks the Controller's replication.</span></pre></td></tr><tr><td data-num="69"></td><td><pre>	RPC_Multicast_OpenChannelForClass<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token class-name">AServerStatReplicator</span><span class="token operator">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> FRepGraphActorClassSettings<span class="token operator">&amp;</span> ActorClassSettings <span class="token operator">:</span> LyraRepGraphSettings<span class="token operator">-></span>ClassSettings<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="71"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>ActorClassSettings<span class="token punctuation">.</span>bAddToRPC_Multicast_OpenChannelForClassMap<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="73"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>			<span class="token keyword">if</span> <span class="token punctuation">(</span>UClass<span class="token operator">*</span> StaticActorClass <span class="token operator">=</span> ActorClassSettings<span class="token punctuation">.</span><span class="token function">GetStaticActorClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="75"></td><td><pre>			<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="76"></td><td><pre>				RPC_Multicast_OpenChannelForClass<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>StaticActorClass<span class="token punctuation">,</span> ActorClassSettings<span class="token punctuation">.</span>bRPC_Multicast_OpenChannelForClass<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="78"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="80"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>整体看下来主要做了以下几件事：</p><ul><li>初始化所有 Actor 类型的路由策略。这会决定哪些类型的 Actor 会受到哪些优化策略影响。</li><li>给 Character 做了一定的优化。设置了些许权重，增加了 LyraCharacter 位置属性的 FastShared 同步。</li><li>设置了销毁信息内对于距离的限制，以及 RPC 调用时对于类型的准入和接收条件。这会决定哪些对象可以执行 RPC 调用，哪些对象可以收到 RPC 广播。</li></ul><p>再来看看另一个比较重要的接口 <strong>InitGlobalGraphNodes</strong>：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">ULyraReplicationGraph</span><span class="token operator">::</span><span class="token function">InitGlobalGraphNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token comment">// -----------------------------------------------</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token comment">//	Spatial Actors</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token comment">// -----------------------------------------------</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	GridNode <span class="token operator">=</span> CreateNewNode<span class="token operator">&lt;</span>UReplicationGraphNode_GridSpatialization2D<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	GridNode<span class="token operator">-></span>CellSize <span class="token operator">=</span> Lyra<span class="token operator">::</span>RepGraph<span class="token operator">::</span>CellSize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	GridNode<span class="token operator">-></span>SpatialBias <span class="token operator">=</span> <span class="token function">FVector2D</span><span class="token punctuation">(</span>Lyra<span class="token operator">::</span>RepGraph<span class="token operator">::</span>SpatialBiasX<span class="token punctuation">,</span> Lyra<span class="token operator">::</span>RepGraph<span class="token operator">::</span>SpatialBiasY<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>Lyra<span class="token operator">::</span>RepGraph<span class="token operator">::</span>DisableSpatialRebuilds<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		GridNode<span class="token operator">-></span><span class="token function">AddToClassRebuildDenyList</span><span class="token punctuation">(</span><span class="token class-name">AActor</span><span class="token operator">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Disable All spatial rebuilding</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	</pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token function">AddGlobalGraphNode</span><span class="token punctuation">(</span>GridNode<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token comment">// -----------------------------------------------</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token comment">//	Always Relevant (to everyone) Actors</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token comment">// -----------------------------------------------</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	AlwaysRelevantNode <span class="token operator">=</span> CreateNewNode<span class="token operator">&lt;</span>UReplicationGraphNode_ActorList<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token function">AddGlobalGraphNode</span><span class="token punctuation">(</span>AlwaysRelevantNode<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token comment">// -----------------------------------------------</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token comment">//	Player State specialization. This will return a rolling subset of the player states to replicate</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	<span class="token comment">// -----------------------------------------------</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	ULyraReplicationGraphNode_PlayerStateFrequencyLimiter<span class="token operator">*</span> PlayerStateNode <span class="token operator">=</span> CreateNewNode<span class="token operator">&lt;</span>ULyraReplicationGraphNode_PlayerStateFrequencyLimiter<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token function">AddGlobalGraphNode</span><span class="token punctuation">(</span>PlayerStateNode<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里定制了 LyraGame 的专属同步方案：</p><ul><li>基于 UReplicationGraphNode_GridSpatialization2D 的全局优化，对地图做网格切分，优化同步。</li><li>基于 UReplicationGraphNode_ActorList 的全局可见方案。</li><li>基于 ULyraReplicationGraphNode_PlayerStateFrequencyLimiter 的全局定时角色状态同步。</li></ul><p>剩下最后一个比较重要的接口 ——<strong>InitConnectionGraphNodes</strong>：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">ULyraReplicationGraph</span><span class="token operator">::</span><span class="token function">InitConnectionGraphNodes</span><span class="token punctuation">(</span>UNetReplicationGraphConnection<span class="token operator">*</span> RepGraphConnection<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token class-name">Super</span><span class="token operator">::</span><span class="token function">InitConnectionGraphNodes</span><span class="token punctuation">(</span>RepGraphConnection<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>	ULyraReplicationGraphNode_AlwaysRelevant_ForConnection<span class="token operator">*</span> AlwaysRelevantConnectionNode <span class="token operator">=</span> CreateNewNode<span class="token operator">&lt;</span>ULyraReplicationGraphNode_AlwaysRelevant_ForConnection<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token comment">// This node needs to know when client levels go in and out of visibility</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	RepGraphConnection<span class="token operator">-></span>OnClientVisibleLevelNameAdd<span class="token punctuation">.</span><span class="token function">AddUObject</span><span class="token punctuation">(</span>AlwaysRelevantConnectionNode<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ULyraReplicationGraphNode_AlwaysRelevant_ForConnection<span class="token operator">::</span>OnClientLevelVisibilityAdd<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	RepGraphConnection<span class="token operator">-></span>OnClientVisibleLevelNameRemove<span class="token punctuation">.</span><span class="token function">AddUObject</span><span class="token punctuation">(</span>AlwaysRelevantConnectionNode<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ULyraReplicationGraphNode_AlwaysRelevant_ForConnection<span class="token operator">::</span>OnClientLevelVisibilityRemove<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token function">AddConnectionGraphNode</span><span class="token punctuation">(</span>AlwaysRelevantConnectionNode<span class="token punctuation">,</span> RepGraphConnection<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个也比较简单，上面两个主要是全局的策略，这里主要是定制了 Connection 级别的策略。为每个 Connection 设置了改良版的 ULyraReplicationGraphNode_AlwaysRelevant_ForConnection 节点。</p><p>还有一些常规化的定制逻辑，例如：</p><ul><li>路由接口：RouteRemoveXXX、RouteAddXXX。</li><li>事件注册：OnXXXAdd、OnXXXRemove。</li><li>定义了若干全局数据。</li></ul><h3 id="ulyrareplicationgraphnode_alwaysrelevant_forconnection"><a class="anchor" href="#ulyrareplicationgraphnode_alwaysrelevant_forconnection">#</a> ULyraReplicationGraphNode_AlwaysRelevant_ForConnection</h3><p>主要功能是在每次收集同步对象时，会把当前 Connection 关联的所有 Viewers 以及和该 Viewers 有依赖关系的对象加入同步列表。</p><p>同时基于关卡的可见性，从 ULyraReplicationGraph 获取可见流式关卡中的永远可见对象列表加入同步列表。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">ULyraReplicationGraphNode_AlwaysRelevant_ForConnection</span><span class="token operator">::</span><span class="token function">GatherActorListsForConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> FConnectionGatherActorListParameters<span class="token operator">&amp;</span> Params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	ULyraReplicationGraph<span class="token operator">*</span> LyraGraph <span class="token operator">=</span> CastChecked<span class="token operator">&lt;</span>ULyraReplicationGraph<span class="token operator">></span><span class="token punctuation">(</span><span class="token function">GetOuter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	ReplicationActorList<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 这里主要是收集 Connection 中关联的 Viewers 和 ViewTargets.</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 因为一个 Connection 可能会有多个 ChildConnection，因此也可能出现多个 Viewers 和 ViewTargets.</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> FNetViewer<span class="token operator">&amp;</span> CurViewer <span class="token operator">:</span> Params<span class="token punctuation">.</span>Viewers<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>		ReplicationActorList<span class="token punctuation">.</span><span class="token function">ConditionalAdd</span><span class="token punctuation">(</span>CurViewer<span class="token punctuation">.</span>InViewer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		ReplicationActorList<span class="token punctuation">.</span><span class="token function">ConditionalAdd</span><span class="token punctuation">(</span>CurViewer<span class="token punctuation">.</span>ViewTarget<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>ALyraPlayerController<span class="token operator">*</span> PC <span class="token operator">=</span> Cast<span class="token operator">&lt;</span>ALyraPlayerController<span class="token operator">></span><span class="token punctuation">(</span>CurViewer<span class="token punctuation">.</span>InViewer<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>			<span class="token comment">// 50% throttling of PlayerStates.</span></pre></td></tr><tr><td data-num="14"></td><td><pre>			<span class="token keyword">const</span> <span class="token keyword">bool</span> bReplicatePS <span class="token operator">=</span> <span class="token punctuation">(</span>Params<span class="token punctuation">.</span>ConnectionManager<span class="token punctuation">.</span>ConnectionOrderNum <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>Params<span class="token punctuation">.</span>ReplicationFrameNum <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>			<span class="token keyword">if</span> <span class="token punctuation">(</span>bReplicatePS<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>			<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>				<span class="token keyword">if</span> <span class="token punctuation">(</span>APlayerState<span class="token operator">*</span> PS <span class="token operator">=</span> PC<span class="token operator">-></span>PlayerState<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>				<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bInitializedPlayerState<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>					<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>						bInitializedPlayerState <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>						FConnectionReplicationActorInfo<span class="token operator">&amp;</span> ConnectionActorInfo <span class="token operator">=</span> Params<span class="token punctuation">.</span>ConnectionManager<span class="token punctuation">.</span>ActorInfoMap<span class="token punctuation">.</span><span class="token function">FindOrAdd</span><span class="token punctuation">(</span>PS<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>						ConnectionActorInfo<span class="token punctuation">.</span>ReplicationPeriodFrame <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>					<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>					ReplicationActorList<span class="token punctuation">.</span><span class="token function">ConditionalAdd</span><span class="token punctuation">(</span>PS<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>				<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>			FCachedAlwaysRelevantActorInfo<span class="token operator">&amp;</span> LastData <span class="token operator">=</span> PastRelevantActorMap<span class="token punctuation">.</span><span class="token function">FindOrAdd</span><span class="token punctuation">(</span>CurViewer<span class="token punctuation">.</span>Connection<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>			<span class="token keyword">if</span> <span class="token punctuation">(</span>ALyraCharacter<span class="token operator">*</span> Pawn <span class="token operator">=</span> Cast<span class="token operator">&lt;</span>ALyraCharacter<span class="token operator">></span><span class="token punctuation">(</span>PC<span class="token operator">-></span><span class="token function">GetPawn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>			<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>				<span class="token function">UpdateCachedRelevantActor</span><span class="token punctuation">(</span>Params<span class="token punctuation">,</span> Pawn<span class="token punctuation">,</span> LastData<span class="token punctuation">.</span>LastViewer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>				<span class="token keyword">if</span> <span class="token punctuation">(</span>Pawn <span class="token operator">!=</span> CurViewer<span class="token punctuation">.</span>ViewTarget<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre>				<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>					ReplicationActorList<span class="token punctuation">.</span><span class="token function">ConditionalAdd</span><span class="token punctuation">(</span>Pawn<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>				<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>			<span class="token keyword">if</span> <span class="token punctuation">(</span>ALyraCharacter<span class="token operator">*</span> ViewTargetPawn <span class="token operator">=</span> Cast<span class="token operator">&lt;</span>ALyraCharacter<span class="token operator">></span><span class="token punctuation">(</span>CurViewer<span class="token punctuation">.</span>ViewTarget<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre>			<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>				<span class="token function">UpdateCachedRelevantActor</span><span class="token punctuation">(</span>Params<span class="token punctuation">,</span> ViewTargetPawn<span class="token punctuation">,</span> LastData<span class="token punctuation">.</span>LastViewTarget<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token comment">// 这里就是打包流式关卡中永远可见的对象。 </span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token comment">// 主要是基于 Connection 对于流式关卡的可见性以及流式关卡本身是否处于 Dormany 状态来判断。</span></pre></td></tr><tr><td data-num="47"></td><td><pre>	<span class="token function">CleanupCachedRelevantActors</span><span class="token punctuation">(</span>PastRelevantActorMap<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>	Params<span class="token punctuation">.</span>OutGatheredReplicationLists<span class="token punctuation">.</span><span class="token function">AddReplicationActorList</span><span class="token punctuation">(</span>ReplicationActorList<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>	FPerConnectionActorInfoMap<span class="token operator">&amp;</span> ConnectionActorInfoMap <span class="token operator">=</span> Params<span class="token punctuation">.</span>ConnectionManager<span class="token punctuation">.</span>ActorInfoMap<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>	TMap<span class="token operator">&lt;</span>FName<span class="token punctuation">,</span> FActorRepListRefView<span class="token operator">></span><span class="token operator">&amp;</span> AlwaysRelevantStreamingLevelActors <span class="token operator">=</span> LyraGraph<span class="token operator">-></span>AlwaysRelevantStreamingLevelActors<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>int32 Idx<span class="token operator">=</span>AlwaysRelevantStreamingLevelsNeedingReplication<span class="token punctuation">.</span><span class="token function">Num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> Idx <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>Idx<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="52"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>		<span class="token keyword">const</span> FName<span class="token operator">&amp;</span> StreamingLevel <span class="token operator">=</span> AlwaysRelevantStreamingLevelsNeedingReplication<span class="token punctuation">[</span>Idx<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre></pre></td></tr><tr><td data-num="55"></td><td><pre>		FActorRepListRefView<span class="token operator">*</span> Ptr <span class="token operator">=</span> AlwaysRelevantStreamingLevelActors<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>StreamingLevel<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>Ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="57"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>			AlwaysRelevantStreamingLevelsNeedingReplication<span class="token punctuation">.</span><span class="token function">RemoveAtSwap</span><span class="token punctuation">(</span>Idx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>			<span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="61"></td><td><pre></pre></td></tr><tr><td data-num="62"></td><td><pre>		FActorRepListRefView<span class="token operator">&amp;</span> RepList <span class="token operator">=</span> <span class="token operator">*</span>Ptr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>RepList<span class="token punctuation">.</span><span class="token function">Num</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="64"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>			<span class="token keyword">bool</span> bAllDormant <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>			<span class="token keyword">for</span> <span class="token punctuation">(</span>FActorRepListType Actor <span class="token operator">:</span> RepList<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="67"></td><td><pre>			<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="68"></td><td><pre>				FConnectionReplicationActorInfo<span class="token operator">&amp;</span> ConnectionActorInfo <span class="token operator">=</span> ConnectionActorInfoMap<span class="token punctuation">.</span><span class="token function">FindOrAdd</span><span class="token punctuation">(</span>Actor<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>				<span class="token keyword">if</span> <span class="token punctuation">(</span>ConnectionActorInfo<span class="token punctuation">.</span>bDormantOnConnection <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="70"></td><td><pre>				<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>					bAllDormant <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>					<span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>				<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="75"></td><td><pre></pre></td></tr><tr><td data-num="76"></td><td><pre>			<span class="token keyword">if</span> <span class="token punctuation">(</span>bAllDormant<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="77"></td><td><pre>			<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="78"></td><td><pre>				AlwaysRelevantStreamingLevelsNeedingReplication<span class="token punctuation">.</span><span class="token function">RemoveAtSwap</span><span class="token punctuation">(</span>Idx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="80"></td><td><pre>			<span class="token keyword">else</span></pre></td></tr><tr><td data-num="81"></td><td><pre>			<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="82"></td><td><pre>				Params<span class="token punctuation">.</span>OutGatheredReplicationLists<span class="token punctuation">.</span><span class="token function">AddReplicationActorList</span><span class="token punctuation">(</span>RepList<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="84"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="85"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="86"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="ulyrareplicationgraphnode_playerstatefrequencylimiter"><a class="anchor" href="#ulyrareplicationgraphnode_playerstatefrequencylimiter">#</a> ULyraReplicationGraphNode_PlayerStateFrequencyLimiter</h3><p>功能大致是为了做 PlayerState 的分帧同步，不过实现上比较糙，这里简单看一下就好：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 每次同步之前重建一下同步列表，同步列表时以每两个 PlayerState 为单位组成的</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">ULyraReplicationGraphNode_PlayerStateFrequencyLimiter</span><span class="token operator">::</span><span class="token function">PrepareForReplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	ReplicationActorLists<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	ForceNetUpdateReplicationActorList<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>	ReplicationActorLists<span class="token punctuation">.</span><span class="token function">AddDefaulted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	FActorRepListRefView<span class="token operator">*</span> CurrentList <span class="token operator">=</span> <span class="token operator">&amp;</span>ReplicationActorLists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>TActorIterator<span class="token operator">&lt;</span>APlayerState<span class="token operator">></span> <span class="token function">It</span><span class="token punctuation">(</span><span class="token function">GetWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> It<span class="token punctuation">;</span> <span class="token operator">++</span>It<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		APlayerState<span class="token operator">*</span> PS <span class="token operator">=</span> <span class="token operator">*</span>It<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsActorValidForReplicationGather</span><span class="token punctuation">(</span>PS<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>			<span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>CurrentList<span class="token operator">-></span><span class="token function">Num</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> TargetActorsPerFrame<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>			ReplicationActorLists<span class="token punctuation">.</span><span class="token function">AddDefaulted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>			CurrentList <span class="token operator">=</span> <span class="token operator">&amp;</span>ReplicationActorLists<span class="token punctuation">.</span><span class="token function">Last</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>		CurrentList<span class="token operator">-></span><span class="token function">Add</span><span class="token punctuation">(</span>PS<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token punctuation">&#125;</span>	</pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">// 收集同步对象的时候，从列表里面通过取余的方式抽取其中一个列表内的两个 PlayerState 进行同步</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">ULyraReplicationGraphNode_PlayerStateFrequencyLimiter</span><span class="token operator">::</span><span class="token function">GatherActorListsForConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> FConnectionGatherActorListParameters<span class="token operator">&amp;</span> Params<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	<span class="token keyword">const</span> int32 ListIdx <span class="token operator">=</span> Params<span class="token punctuation">.</span>ReplicationFrameNum <span class="token operator">%</span> ReplicationActorLists<span class="token punctuation">.</span><span class="token function">Num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	Params<span class="token punctuation">.</span>OutGatheredReplicationLists<span class="token punctuation">.</span><span class="token function">AddReplicationActorList</span><span class="token punctuation">(</span>ReplicationActorLists<span class="token punctuation">[</span>ListIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>ForceNetUpdateReplicationActorList<span class="token punctuation">.</span><span class="token function">Num</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>		Params<span class="token punctuation">.</span>OutGatheredReplicationLists<span class="token punctuation">.</span><span class="token function">AddReplicationActorList</span><span class="token punctuation">(</span>ForceNetUpdateReplicationActorList<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	<span class="token punctuation">&#125;</span>	</pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="性能设计问题"><a class="anchor" href="#性能设计问题">#</a> 性能 &amp;&amp; 设计问题</h2><p>整体看下来，感觉 ReplicationGraph 有些地方实现还是蛮糟糕的：</p><h3 id="各种策略存在强依赖关系"><a class="anchor" href="#各种策略存在强依赖关系">#</a> 各种策略存在强依赖关系</h3><p>ReplicationGraph 虽然看起来足够灵活，但实际上并非如此，每个策略都必须应用在某几个固定场景，虽然提供了灵活的搭配能力，但实际上可搭配点不多。</p><ul><li>UReplicationGraphNode_GridSpatialization2D 通常需要作为 GlobalNode 被使用，如果基于连接的划分，性能开销是不可估量的。因此很难针对连接来定制化同步网格的大小。</li><li>UReplicationGraphNode_GridSpatialization2D 中的 UReplicationGraphNode_GridCell 完全依赖 UReplicationGraphNode_DormancyNode 的实现。这点上不能单纯移除 UReplicationGraphNode_DormancyNode 来解决，难以拆解意味着 DormancyNode 的应用场景非常局限。</li><li>UReplicationGraphNode_GridCell 本身就可有很多个，每个里面都需要维护一个 DormancyNode 和 N 个 ConnectionDormancyNode，数量可能过于庞大。</li><li>UReplicationGraphNode_TearOff_ForConnection 也是内嵌在实现里的，设计上强绑定在 GraphConnection 中，基于全局的擦除还需要自己实现，而且功能上和 DormancyNode 有点冲突。</li><li>ReplicationGraph 内部定义了很多不相干的数据，如： <strong>PrevDormantActorListPerNode</strong>、<strong>NodesVisibleCells</strong>。这些实际上是用于 GridSpatialization2D 和 DormancyNode 的，等于是变相的把这两个节点和框架做了捆绑。</li></ul><h3 id="dormancy-实现很糟糕"><a class="anchor" href="#dormancy-实现很糟糕">#</a> Dormancy 实现很糟糕</h3><p>直觉上应该是 DormancyNode 管理多个 ConnectionDormancyNode。每个 ConnectionDormancyNode 记录自身的休眠节点。对于 GridSpatialization2D 策略下，需要记录每个 Cell 的休眠节点，看起来才比较合理。现在的设计上是：每个 Cell 包含一个 DormancyNode，每个 DormancyNode 管理多个 ConnectionDormancyNode。</p><p>实际上阅读代码过程中其他 GraphNode 的注释中也多次，不得不因为 DormancyNode 而书写一些丑陋的代码，并强调 Dormancy 应该重写了。</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20231117231615916.png" alt="image-20231117231615916"></p><blockquote><p>这仅仅是个人观点，肯定也有很多考虑不周的地方（疯狂叠甲）</p></blockquote><h3 id="各种-array-的查询很糟糕"><a class="anchor" href="#各种-array-的查询很糟糕">#</a> 各种 Array 的查询很糟糕</h3><p>能够明显的感觉到，整个 ReplicationGraph 框架内使用了大量的 Array 结构。最明显的就是 <strong>FConnectionGatherActorListParameters</strong> 以及 <strong>UReplicationGraphNode_ActorList</strong></p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20231117232040541.png" alt="image-20231117232040541"></p><p>带来的性能开销是可以预见的：几乎所有的增删改查操作都需要做遍历，但是 Array 的遍历查询太慢了。</p><h3 id="面对收集结果的去重问题很糟糕"><a class="anchor" href="#面对收集结果的去重问题很糟糕">#</a> 面对收集结果的去重问题很糟糕</h3><p>目前看下来去重逻辑可能只在最终需要同步的时候会校验上次的同步帧。内部实际上 GraphNode 没有对 Actor 的独占性做任何保证，换句话说，任何 Actor 都可能同时存在于多个 GraphNode，这取决于代码写法的合理性。稍不留意就可能导致一个对象被收集多次从而带来额外的性能开销（例如在某个 ConnectionNode 中注册了多个 GraphNode，并且同时会调用 AddNetworkActor）。而且这些问题的暴露和查找可能会比较耗时。</p><h2 id="总结"><a class="anchor" href="#总结">#</a> 总结</h2><p>最后做个总结，就目前的 ReplicationGraph 框架来看，其提供的功能对于大部分项目来说，已经够用了。有基于网格的拆分、休眠、分帧等优化。虽然提供了非常多的优化方案，但框架底层确实存在很多不完善的点有待解决，想要用好还是比较考验项目自身设计的。但 ReplicationGraph 也提供了很多关于同步的思路，例如通过图的方式来规划同步策略，引入 Dormancy、TearOff、DynamicSpatialFrequency 等优化策略，最后附上一张 ReplicationGraph 的全局类图，本篇讲解到此也就结束了：</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/ReplicationGraph%E6%80%BB.png" alt="ReplicationGraph总"></p><h2 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9uYXNobmllLmdpdGh1Yi5pby9ub25lLzIwMTkvMDgvMDUvVUUtcmVwbGljYXRpb24tZ3JhcGguaHRtbA==">https://nashnie.github.io/none/2019/08/05/UE-replication-graph.html</span></li></ul><div class="tags"><a href="/tags/UE5/" rel="tag"><i class="ic i-tag"></i> UE5</a> <a href="/tags/ReplicationGraph/" rel="tag"><i class="ic i-tag"></i> ReplicationGraph</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-11-20 14:28:28" itemprop="dateModified" datetime="2023-11-20T14:28:28+08:00">2023-11-20</time> </span><span id="learning/unreal/Unreal Replication 篇/" class="item leancloud_visitors" data-flag-title="Unreal ReplicationGraph 篇" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 充电</button><p>请我[恰饭]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="鑫酱(●'◡'●) 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="鑫酱(●'◡'●) 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>鑫酱(●'◡'●) <i class="ic i-at"><em>@</em></i>鑫酱</li><li class="link"><strong>本文链接：</strong> <a href="https://hakuya.me/learning/unreal/Unreal%20Replication%20%E7%AF%87/" title="Unreal ReplicationGraph 篇">https://hakuya.me/learning/unreal/Unreal Replication 篇/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/learning/unreal/Unreal%20RPC/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;wallpaper-1255596461.cos.ap-nanjing.myqcloud.com&#x2F;wallpaper (3).jpg" title="Unreal RPC"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> UE</span><h3>Unreal RPC</h3></a></div><div class="item right"><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Serialization%E7%AF%87/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;wallpaper-1255596461.cos.ap-nanjing.myqcloud.com&#x2F;wallpaper (3).jpg" title="PhysX——Serialization篇"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 物理引擎</span><h3>PhysX——Serialization篇</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#unreal-replicationgraph-%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">Unreal ReplicationGraph 篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%84%E6%88%90"><span class="toc-number">1.3.</span> <span class="toc-text">数据组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#actor%E7%B1%BB%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AEclassmap%E7%BA%AF%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">Actor 类全局数据「ClassMap」（纯配置数据）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#actor%E7%B1%BB%E5%AE%9E%E4%BE%8B%E7%89%B9%E5%8C%96%E6%95%B0%E6%8D%AEactormap%E9%85%8D%E7%BD%AE%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">Actor 类实例特化数据「ActorMap」（配置 &amp;&amp; 运行时数据）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connection%E7%B1%BB%E5%AE%9E%E4%BE%8B%E4%B8%AD%E5%90%84%E4%B8%AAactor%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AEactorinfomap%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.3.</span> <span class="toc-text">Connection 类实例中各个 Actor 实例数据「ActorInfoMap」（运行时数据）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%89%91%E5%AE%A2"><span class="toc-number">1.4.</span> <span class="toc-text">三剑客</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ureplicationgraph"><span class="toc-number">1.4.1.</span> <span class="toc-text">UReplicationGraph</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-classmap-actormap"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">深入了解 ClassMap &amp;&amp; ActorMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unetreplicationgraphconnection"><span class="toc-number">1.4.2.</span> <span class="toc-text">UNetReplicationGraphConnection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-actorinfomap"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">深入了解 ActorInfoMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E5%88%9D%E8%A7%81%E7%AB%AF%E5%80%AA"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">优化策略初见端倪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">销毁对象的处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ureplicationgraphnode"><span class="toc-number">1.4.3.</span> <span class="toc-text">UReplicationGraphNode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ureplicationgraphnode_actorlist"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">UReplicationGraphNode_ActorList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ureplicationgraphnode_gridspatialization2d"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">UReplicationGraphNode_GridSpatialization2D</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ureplicationgraphnode_alwaysrelevant"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">UReplicationGraphNode_AlwaysRelevant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ureplicationgraphnode_alwaysrelevant_forconnection"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">UReplicationGraphNode_AlwaysRelevant_ForConnection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ureplicationgraphnode_tearoff_forconnection"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">UReplicationGraphNode_TearOff_ForConnection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ureplicationgraphnode_dormancynode"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">UReplicationGraphNode_DormancyNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ureplicationgraphnode_connectiondormancynode"><span class="toc-number">1.4.3.7.</span> <span class="toc-text">UReplicationGraphNode_ConnectionDormancyNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ureplicationgraphnode_dynamicspatialfrequency"><span class="toc-number">1.4.3.8.</span> <span class="toc-text">UReplicationGraphNode_DynamicSpatialFrequency</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.4.4.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E5%90%8C%E6%AD%A5"><span class="toc-number">1.5.</span> <span class="toc-text">如何知道哪些对象需要同步？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.</span> <span class="toc-text">其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#default-fastshared"><span class="toc-number">1.6.1.</span> <span class="toc-text">Default &amp;&amp; FastShared</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replayconnection"><span class="toc-number">1.6.2.</span> <span class="toc-text">ReplayConnection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swaproles"><span class="toc-number">1.6.3.</span> <span class="toc-text">SwapRoles</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E5%8C%96%E6%A1%88%E4%BE%8B-lyra"><span class="toc-number">1.7.</span> <span class="toc-text">定制化案例 Lyra</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ulyrareplicationgraph"><span class="toc-number">1.7.1.</span> <span class="toc-text">ULyraReplicationGraph</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ulyrareplicationgraphnode_alwaysrelevant_forconnection"><span class="toc-number">1.7.2.</span> <span class="toc-text">ULyraReplicationGraphNode_AlwaysRelevant_ForConnection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ulyrareplicationgraphnode_playerstatefrequencylimiter"><span class="toc-number">1.7.3.</span> <span class="toc-text">ULyraReplicationGraphNode_PlayerStateFrequencyLimiter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">性能 &amp;&amp; 设计问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E7%AD%96%E7%95%A5%E5%AD%98%E5%9C%A8%E5%BC%BA%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.8.1.</span> <span class="toc-text">各种策略存在强依赖关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dormancy-%E5%AE%9E%E7%8E%B0%E5%BE%88%E7%B3%9F%E7%B3%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">Dormancy 实现很糟糕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D-array-%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%BE%88%E7%B3%9F%E7%B3%95"><span class="toc-number">1.8.3.</span> <span class="toc-text">各种 Array 的查询很糟糕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%AF%B9%E6%94%B6%E9%9B%86%E7%BB%93%E6%9E%9C%E7%9A%84%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E5%BE%88%E7%B3%9F%E7%B3%95"><span class="toc-number">1.8.4.</span> <span class="toc-text">面对收集结果的去重问题很糟糕</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-number">1.10.</span> <span class="toc-text">参考文档</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/learning/unreal/UE%20%E5%9F%BA%E7%A1%80%E7%AF%87/" rel="bookmark" title="UE 基础篇">UE 基础篇</a></li><li><a href="/learning/unreal/UE%20%E8%93%9D%E5%9B%BE%E7%AF%87/" rel="bookmark" title="UE 蓝图篇">UE 蓝图篇</a></li><li><a href="/learning/unreal/UE%20VirtualMachine/" rel="bookmark" title="UE VirtualMachine">UE VirtualMachine</a></li><li><a href="/learning/unreal/UE%20Delegate/" rel="bookmark" title="UE Delegate">UE Delegate</a></li><li><a href="/learning/unreal/UE%20%E8%B5%84%E4%BA%A7%E5%AF%BC%E5%87%BA%E5%92%8C%E5%8A%A0%E8%BD%BD/" rel="bookmark" title="UE 资产导出和加载">UE 资产导出和加载</a></li><li><a href="/learning/unreal/Unreal%20%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B/" rel="bookmark" title="Unreal 握手流程">Unreal 握手流程</a></li><li><a href="/learning/unreal/Unreal%20RPC/" rel="bookmark" title="Unreal RPC">Unreal RPC</a></li><li class="active"><a href="/learning/unreal/Unreal%20Replication%20%E7%AF%87/" rel="bookmark" title="Unreal ReplicationGraph 篇">Unreal ReplicationGraph 篇</a></li><li><a href="/learning/unreal/Unreal%20Chaos%20%E5%AF%BC%E5%87%BA%E4%B8%BA%20PhysX%20%E7%89%A9%E7%90%86%E6%96%87%E4%BB%B6/" rel="bookmark" title="Unreal Chaos 导出为 PhysX 物理文件">Unreal Chaos 导出为 PhysX 物理文件</a></li><li><a href="/learning/unreal/Unreal%20Iris%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/" rel="bookmark" title="Unreal Iris（一）概述">Unreal Iris（一）概述</a></li><li><a href="/learning/unreal/Unreal%20Iris%EF%BC%88%E4%BA%8C%EF%BC%89ReplicationState/" rel="bookmark" title="Unreal Iris（二）ReplicationState">Unreal Iris（二）ReplicationState</a></li><li><a href="/learning/unreal/Unreal%20Iris%EF%BC%88%E4%B8%89%EF%BC%89Filtering%20&&%20Prioritization/" rel="bookmark" title="Unreal Iris（三）Filtering && Prioritization">Unreal Iris（三）Filtering && Prioritization</a></li><li><a href="/learning/unreal/Unreal%20Iris%EF%BC%88%E5%9B%9B%EF%BC%89DataStream/" rel="bookmark" title="Unreal Iris（四）DataStream">Unreal Iris（四）DataStream</a></li><li><a href="/learning/unreal/Unreal%20Iris%EF%BC%88%E4%BA%94%EF%BC%89BaseLine%20&&%20DeltaCompression/" rel="bookmark" title="Unreal Iris（五）BaseLine && DeltaCompression">Unreal Iris（五）BaseLine && DeltaCompression</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="鑫酱(●'◡'●)" data-src="/images/avatar.jpg"><p class="name" itemprop="name">鑫酱(●'◡'●)</p><div class="description" itemprop="description">整天摸鱼，却妄想拯救世界的技术宅</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">110</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">25</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">67</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsbGVuR1g=" title="https:&#x2F;&#x2F;github.com&#x2F;AllenGX"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTgwNTM4MjQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;80538242"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjE0MTM5MDcxNTNAcXEuY29t" title="mailto:1413907153@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>好友</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>网址</a></li><li class="item"><a href="/travellings/" rel="section"><i class="ic i-paper-plane"></i>传送门</a></li><li class="item"><a href="/mikutap/" rel="section"><i class="ic i-star"></i>Mikutap</a></li><li class="item"><a href="/restart/" rel="section"><i class="ic i-sun"></i>RestartLife</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/learning/unreal/Unreal%20RPC/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Serialization%E7%AF%87/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game101/" title="分类于 Games101图形渲染">Games101图形渲染</a></div><span><a href="/learning/games/Game101/%E5%8D%81%E5%9B%9B%E3%80%81Ray%20Tracing%20&&%20Rasterization/" title="十四、Ray Tracing &amp;&amp; Rasterization">十四、Ray Tracing && Rasterization</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/physx/" title="分类于 物理引擎">物理引擎</a></div><span><a href="/learning/physx/PhysX%E2%80%94%E2%80%94Simulate%E7%AF%87/" title="PhysX——Simulate篇">PhysX——Simulate篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game101/" title="分类于 Games101图形渲染">Games101图形渲染</a></div><span><a href="/learning/games/Game101/%E4%B9%9D%E3%80%81Shading%EF%BC%88%E4%B8%8B%EF%BC%89%E2%80%94%E2%80%94Texture%20Mapping%20Cont/" title="九、Shading（下）——Texture Mapping Cont">九、Shading（下）——Texture Mapping Cont</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game202/" title="分类于 GAME202高质量实时渲染">GAME202高质量实时渲染</a></div><span><a href="/learning/games/Game202/%E5%9B%9B%E3%80%81Real-time%20Global%20Illumination/" title="四、Real-time Global Illumination">四、Real-time Global Illumination</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/tasklist/" title="分类于 任务清单">任务清单</a></div><span><a href="/tasklist/plan-table/" title="计划表">计划表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/" title="分类于 编程语言">编程语言</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/learning/programlanguage/cpp/%E4%B9%9D%E3%80%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/" title="九、内存模型和名称空间">九、内存模型和名称空间</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game101/" title="分类于 Games101图形渲染">Games101图形渲染</a></div><span><a href="/learning/games/Game101/%E5%8D%81%E4%B8%80%E3%80%81Geometry%EF%BC%88%E4%B8%AD%EF%BC%89%E2%80%94%E2%80%94Curves/" title="十一、Geometry（中）——Curves">十一、Geometry（中）——Curves</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game101/" title="分类于 Games101图形渲染">Games101图形渲染</a></div><span><a href="/learning/games/Game101/%E5%85%AB%E3%80%81Shading%EF%BC%88%E4%B8%AD%EF%BC%89%E2%80%94%E2%80%94Pipeline%20&&%20Texture%20Mapping/" title="八、Shading（中）——Pipeline &amp;&amp; Texture Mapping">八、Shading（中）——Pipeline && Texture Mapping</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/japanese/" title="分类于 日语">日语</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/japanese/primary/" title="分类于 日语初级">日语初级</a></div><span><a href="/learning/japanese/primary/%E5%8D%81%E4%BA%8C%E3%80%81%E5%B0%8F%E6%9D%8E%E6%AF%94%E5%B0%8F%E6%A3%AE%E5%B9%B4%E8%BD%BB/" title="十二、小李比小森年轻">十二、小李比小森年轻</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/" title="分类于 编程语言">编程语言</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/learning/programlanguage/cpp/%E5%8D%81%E5%85%AD%E3%80%81string%20%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/" title="十六、string 类和标准模板库">十六、string 类和标准模板库</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">鑫酱(●'◡'●) @ 个人博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">641k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:43</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"learning/unreal/Unreal Replication 篇/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/animejs@3.2.0/lib/anime.min.js,npm/katex@0.12.0/dist/contrib/copy-tex.min.js,npm/frappe-charts@1.5.0/dist/frappe-charts.min.iife.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/quicklink@2/dist/quicklink.umd.js,gh/amehime/MiniValine@4.2.2-beta10/dist/MiniValine.min.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b6d809b500bd6f0040117088899bc7bf";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>