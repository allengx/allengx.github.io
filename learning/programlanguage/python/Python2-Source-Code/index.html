<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="XqWEZ-KjvQT4IfXzxYvH-PEc--_zN6GqthY2jBsqOs4"><meta name="msvalidate.01" content="4E28E3FDD5912EBBB84869B17359650D"><meta name="baidu-site-verification" content="code-dwpSTDBLS2"><link rel="alternate" type="application/rss+xml" title="鑫酱" href="https://hakuya.me/rss.xml"><link rel="alternate" type="application/atom+xml" title="鑫酱" href="https://hakuya.me/atom.xml"><link rel="alternate" type="application/json" title="鑫酱" href="https://hakuya.me/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Python,源码"><link rel="canonical" href="https://hakuya.me/learning/programlanguage/python/Python2-Source-Code/"><title>python2源码剖析 - python - 编程语言 - 学习 | 个人博客 = 鑫酱 = 笔记本</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">python2源码剖析</h1><div class="meta"><span class="item" title="创建时间：2020-10-08 14:49:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-10-08T14:49:00+08:00">2020-10-08</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>19k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">个人博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper_6.jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper_5.jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (24).jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper_1.jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (11).jpg"></li><li class="item" data-background-image="https://wallpaper-1255596461.cos.ap-nanjing.myqcloud.com/wallpaper (17).jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learning/" itemprop="item" rel="index" title="分类于 学习"><span itemprop="name">学习</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learning/programlanguage/" itemprop="item" rel="index" title="分类于 编程语言"><span itemprop="name">编程语言</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/learning/programlanguage/python/" itemprop="item" rel="index" title="分类于 python"><span itemprop="name">python</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hakuya.me/learning/programlanguage/python/Python2-Source-Code/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="鑫酱(●'◡'●)"><meta itemprop="description" content="笔记本, 整天摸鱼，却妄想拯救世界的技术宅"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鑫酱"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>以下为个人学习笔记整理</p></div><h1 id="python源码阅读"><a class="anchor" href="#python源码阅读">#</a> python 源码阅读</h1><h2 id="数据类型分析"><a class="anchor" href="#数据类型分析">#</a> 数据类型分析</h2><h3 id="pyintobjectpython中的int类型"><a class="anchor" href="#pyintobjectpython中的int类型">#</a> PyIntObject——python 中的 int 类型</h3><ul><li>python 计算两个整数 ()<ul><li>出现溢出后会转换成 long 类型（无限大整数）。</li></ul></li><li>python 整数缓存<ul><li><code>[-5~256]</code> 的整数。</li><li>提供多个缓存块，每个能够存放 <code>(100/8)</code> 数量的 int 类型。</li><li>控制这些块的结构是一个单向链表（指向每个块中第一个违背使用的内存块）。</li><li>申请新的缓存块采用头插法。</li><li>空闲地址指针 (free_list) 会串起所有缓存块的地址空间 (单链表)。</li><li>对象释放后会以头插的形式再次加入到 (free_list)。</li></ul></li></ul><blockquote><p>隐患：py2.5 之前的版本（之后的不清楚），malloc 出来的缓存块没有一个回收机制，即：创建足够多的对象（malloc 足够多的缓存块）会导致另一种意义上的内存被榨干。</p></blockquote><h3 id="pystringobjectpython中的string类型"><a class="anchor" href="#pystringobjectpython中的string类型">#</a> PyStringObject——python 中的 string 类型</h3><ul><li>字符串的 hash<ul><li>初始为 -1。</li><li>字符串 hash 采用的算法不够理想，性能消耗较大，会对每个字符进行 <code>乘</code> 操作。</li></ul></li><li>字符串的特性<ul><li>长度不能超过 <code>(2**32)/2</code> ，大概是 21 亿多位，2GB 左右大小。超过则不会创建。</li></ul></li><li>intern 内存共享<ul><li>针对相同字符串，<s>不重复创建</s>（其实还是会创建，再销毁），它们共享同一块数据。</li><li>只会生效在 <code>PyStringObject</code> 对象，其子类不会生效。</li><li>创建新对象时会判断是否已经存在，如果已经存在了，会删除原来创建的对象，然后修改其指针指向。</li></ul></li><li>字符缓冲区<ul><li>针对单个字符进行缓存，功能类似整数缓存，长度为 (2**8)——256 个字符。</li><li>初始阶段为空，每次创键新的字符，且不再缓存区内时，进行 intern 操作后，加入进去。</li><li><code>+</code> 操作在 string 中执行效率非常低下（string 对象本身是不可变长类型），推荐使用 <code>join</code> 来一次处理多个。</li></ul></li></ul><h3 id="pylistobjectpython中的list类型"><a class="anchor" href="#pylistobjectpython中的list类型">#</a> PyListObject——python 中的 list 类型</h3><ul><li>形如 c++ 的 vector，本质还是一个数组，分配空间时，多分配一部分，用于动态扩充。</li><li>管理 list 的指针同样也有一块缓存区，可存储数量是 80 个。如果已经全部占用，则会通过 <code>GC_NEW</code> 的方式创建新的。</li><li>容量调整。在容量不在限制范围内（1/2 容量～容量上限之间）。会进行（扩容 / 缩容）操作，调整方法为： <code>newsize/8 + (newsize &lt;9 ? 3:6) + newsize</code></li><li>负值索引的秘诀就在，获取下标的时候针对负数执行 <code>+size</code> 操作</li><li>insert 对于 list 来说性能消耗要比 append 高，因为需要后移 insert 之后的元素。</li><li>对象销毁后会尝试加入缓存区，如果缓冲区满了则释放掉。但是对象管理的内存会被归还。</li><li>销毁后放回缓冲区的对象会替换原来正在被使用的缓存对象，但是这并不影响。因为被剔除的对象正在被其他对象使用，所以不会被释放。只是不被缓存区管理了。</li></ul><h3 id="pydictobjectpython中的dict类型"><a class="anchor" href="#pydictobjectpython中的dict类型">#</a> PyDictObject——python 中的 dict 类型</h3><ul><li>数据结构是 hashtable，采用开放定址法进行冲突解决（二次探测）。</li><li>伪删除，字典 key 和 value 被删除时，会暂时保留 key，并且赋值为 dummy，保证能够继续通过探测链找到后续节点。但是也可以对处于 dummy 的 key 进行赋值。相当于占着坑位。</li><li>dict 的 entry 的三种状态<ul><li>active（key，val 都不为 null）</li><li>dummy（key 为 dummy，val 为 null）</li><li>unused（key，val 都是 null）</li></ul></li><li>hashtable 的最初大小为 <code>8</code> ，dict 对象的创建同样使用了缓冲池，方式等同于 List。缓存 80 个。</li><li>hashtable 的映射函数是直接用某个对象的 hash 值和 dict 的大小做 <code>与</code> 操作保证结果小于等于 dict 大小。</li><li>判断 key 是否存在需要判断 key 的地址是否相同，不相同再去判断 值的 hash 是否相同，相同再去进行对应的比较。</li><li>hash 匹配失败后的再次 hash 策略：<ul><li>上一个 entry 的 hash 与上容器大小为 <code>i</code></li><li>第一个 entry 的 hash 为 <code>k</code></li><li>冲突次数 <code>s</code></li><li>dict 容器大小为 <code>m</code></li><li>下一个地址公式： <code>（i * 4 + i + k / （4 * s * 常量） + 1） &amp; m</code></li></ul></li><li>变更容量操作：<ul><li>装载率： <code>active和dummy的数量 / 总容量</code></li><li>当执行插入操作时，有 Unused 或者 Dummy 对象被填充，并且插入后装载率≥2/3 会进行扩容。</li><li>变容方式 当前 <code>active的节点数*(active的节点数 &gt; 50000 ? 2 : 4)</code> ，如果大于 50000 变容为原来 active 节点的 2 倍。否则变容为 4 倍。</li><li>上面的规则只是期望的变容值，实际结果还需要再次计算，计算方式为 8 的指数增长≥期望变容值。例如期望变容 20，那么最终扩容值会是 <code>8*2*2 = 32</code></li><li>判断变容后和之前容量是否为 8，是则不需要变容。否则，分配新内存，把原来的 active 数据插入到新的内存中。释放原有内存。</li><li>触发缩容的情况：在 active 节点较少，dummy 节点较多，进行插入操作，使得变容条件成立时，触发缩容。python2.7 可能不生效，3.7 可以。</li></ul></li></ul><h2 id="python的编译细节"><a class="anchor" href="#python的编译细节">#</a> python 的编译细节</h2><h3 id="pyc文件"><a class="anchor" href="#pyc文件">#</a> pyc 文件</h3><ul><li>运行时的 python 中，字节码会被存储在 PyCodeObject 中。如果一个代码块被其他模块引用（import），python 会首先去寻找对应的 pyc 文件或者 dll 文件，如果没有则会把字节码内容编译到 pyc 内，再 import，pyc 文件。本质上 pyc 文件是 python 运行时对 PyCodeObject 的一个承载。</li><li>pyc 文件保存的内容都是以二进制的形式。记录内容：<ul><li>magic number 用于版本控制</li><li>time 时间戳</li><li>PyCodeObject 对象</li></ul></li></ul><h3 id="pyframeobject对象"><a class="anchor" href="#pyframeobject对象">#</a> PyFrameObject 对象</h3><ul><li>运行时的 python 内部对象。可以理解为 python 中一段 code block 所生成的对象。</li><li>维护了当前 code block 的全部内容：<ul><li>loacl: 本地变量。</li><li>global: 全局变量。</li><li>builtin: 内建变量。</li><li>f_back: 用于返回上一层的指针。</li></ul></li><li>维护 PyFrameObject 的「栈」空间:<ul><li>f_valuestack: 指向栈的顶部。</li><li>f_stacktop: 指向当前栈顶。</li><li>f_localsplus: 栈起始空间（栈顶等于栈起始空间 + extras）</li><li>extras: 一些指针等额外的空间。</li></ul></li></ul><h2 id="python控制流"><a class="anchor" href="#python控制流">#</a> python 控制流</h2><ul><li><p><code>if</code> 控制流 ——compare 操作</p><ul><li>if 控制流的跳转操作只能向前。</li><li>原理：通过 <code>JUMP_IF_FALSE</code> 和 <code>JUMP_IF_TRUE</code> 和 <code>JUMP_FORWARD</code> 在不同代码片段实现跳转。</li><li>if 控制流通常涉及到比较操作。python 的比较分为 <code>quick_compare</code> 和 <code>slow_compare</code> ，两者速度相差甚远<ul><li>快比较适用于两个都是整数类型</li><li>其他情况下会执行慢比较</li></ul></li><li>常见的比较类型：<ul><li><code>&lt;</code></li><li><code>&gt;</code></li><li><code>==( is)</code></li><li><code>!=</code></li><li><code>&gt;=</code></li><li><code>&lt;=</code></li><li><code>in</code></li></ul></li><li>慢比较时，如果两个对象类型相同，且不是自定义对象，那么 python 会使用 <code>tp_richcompare</code> 比较器进行比较，如果没有定义 <code>tp_richcompare</code> 或者不满足前面的条件，则会使用用户自定义的 <code>tp_compare</code> 进行比较。如果上述两个比较器均未实现，python 还会尝试调用 <code>do_richcmp</code> 进行最后的垂死挣扎，这也是慢比较低下的原因。</li><li>goto 指令：<ul><li>JUMP_FORWARD：跳转到 <code>if else</code> 语句的最终结尾</li><li>JUMP_IF_FALSE：跳转到对应 false 的逻辑处</li><li>JUMP_IF_TRUE：跳转到对应 true 的逻辑处</li></ul></li></ul></li><li><p><code>for</code> 控制流</p><ul><li>for 控制流的跳转操作可以向前也可以回退。</li><li>原理：for 语句会把全部对象顺序压入栈中，并把对象的迭代器设置为栈顶，然后通过 SET_TOP 跳转到栈顶，根据迭代器的 tp_iternext 找到对应的元素，进行迭代。</li><li>goto 指令：<ul><li>JUMP_ABSOLUTE：回到 FOR_ITER 指令位置，重新开始迭代下一个对象</li></ul></li></ul></li><li><p><code>switch case</code> 控制流</p><ul><li>没有了</li></ul></li><li><p><code>while</code> 控制流</p><ul><li>while 和 for 控制流类似。</li></ul></li><li><p><code>exception</code> 控制流</p><ul><li>异常控制流主要是处理 python 程序在执行过程中如何抛出和捕获异常的控制流。</li><li>原理：程序执行过程中会构建一个调用栈，当执行到某个函数触发了异常，程序将通过 <code>PyEval_ExalFrameEx</code> 函数进行处理，如果没有检测到 except 时， 函数的状态会从 <code>WHY_NOT</code> 转变为 <code>WHY_EXCEPTION</code> ，并返回 NULL，同时调整栈指针指向上一层。</li><li>异常控制流程图：</li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200927160601568.png" alt="image-20200927160601568"></p><ul><li><code>PyEval_ExalFrameEx</code> 函数伪代码：</li></ul></li></ul><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>PyObject<span class="token operator">*</span> <span class="token function">PyEval_EvalFrameEx</span><span class="token punctuation">(</span>PyFrameObject <span class="token operator">*</span>f<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 非正常执行</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>why <span class="token operator">!=</span> WHY_NOT <span class="token operator">&amp;&amp;</span> f<span class="token operator">-></span>f_iblock <span class="token operator">></span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            PyTryBlock <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token function">PyFrame_BlockPop</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 有 finally 或者 except 语句</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">-></span>b_type <span class="token operator">==</span> SETUP_FINALLY <span class="token operator">||</span> b<span class="token operator">-></span>b_type <span class="token operator">==</span> SETUP_EXCEPT <span class="token operator">&amp;&amp;</span> why <span class="token operator">==</span> WHY_EXCEPTION<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                 <span class="token comment">// 出现异常，先把异常信息取出来，如果后续没有 except，需要保留现场信息并返回给上一级。</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">if</span><span class="token punctuation">(</span>why <span class="token operator">==</span> WHY_EXCEPTION<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    PyObject <span class="token operator">*</span>exc<span class="token punctuation">,</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token operator">*</span>tb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    <span class="token function">PyErr_Fetch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>exc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>val<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tb<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token function">PUSH</span><span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    <span class="token function">PUSH</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token function">PUSH</span><span class="token punctuation">(</span>exc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token comment">// 设置为正常运转，并调用 except 或 finally</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token comment">//except 执行后会继续在当前栈帧运行（异常被解决）</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token comment">// 无 except 的情况下，finally 执行后会展开到上一层（异常未被解决）</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                why <span class="token operator">=</span> WHY_NOT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token function">JUMPTO</span><span class="token punctuation">(</span>b<span class="token operator">-></span>b_handler<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        </pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>why <span class="token operator">!=</span> WHY_NOT<span class="token punctuation">)</span> <span class="token comment">// 不存在异常处理，展开堆栈，抛给上一层</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>why <span class="token operator">!=</span> WHY_RETURN<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        retval <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 通知前一栈帧有异常</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    </pre></td></tr><tr><td data-num="39"></td><td><pre>   <span class="token comment">// 设置活动栈帧为当前栈帧的上一个，完成栈帧回退</span></pre></td></tr><tr><td data-num="40"></td><td><pre>   tstate<span class="token operator">-></span>frame <span class="token operator">=</span> f<span class="token operator">-></span>f_back<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>   <span class="token keyword">return</span> retval</pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 示例 h () -> g () ->f () -> 1/0</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">def</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    g<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    f<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    </pre></td></tr><tr><td data-num="11"></td><td><pre>h<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200927145147290.png" alt="image-20200927145147290"></p><ul><li><code>try catch</code> 控制流</li></ul><h2 id="python函数机制"><a class="anchor" href="#python函数机制">#</a> python 函数机制</h2><h3 id="pyfunctionobject"><a class="anchor" href="#pyfunctionobject">#</a> PyFunctionObject</h3><p>PyFunctionObject 对象创建后，随之而来的会创建 PyFrameObject（栈帧） 对象，并为其开辟一块内存空间用于存放函数内用到的各种变量。PyCodeObject 对象则是 PyFunctionObject 对象的静态形式，不保留函数运行时的上下文，只存储基本的信息，而 PyFunctionObject 对象则在程序运行时产生。基本结构如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    PyObject <span class="token operator">*</span>func_code<span class="token punctuation">;</span>        <span class="token comment">// 对应函数编译后的 PyCodeObject 对象</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    PyObject <span class="token operator">*</span>func_globals<span class="token punctuation">;</span>     <span class="token comment">// 函数运行时 global 名字空间</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    PyObject <span class="token operator">*</span>func_defaults<span class="token punctuation">;</span>    <span class="token comment">// 默认参数（tuple 或 NULL）</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    PyObject <span class="token operator">*</span>func_closure<span class="token punctuation">;</span>     <span class="token comment">// NULL or tuple of cell objects, 用于实现 closure（闭包）</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    PyObject <span class="token operator">*</span>func_doc<span class="token punctuation">;</span>         <span class="token comment">// 函数文档</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    PyObject <span class="token operator">*</span>func_name<span class="token punctuation">;</span>       <span class="token comment">// 函数名称，函数的 __name__属性</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    PyObject <span class="token operator">*</span>func_dict<span class="token punctuation">;</span>         <span class="token comment">// 函数的 __dict__ 属性</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    PyObject <span class="token operator">*</span>func_weakreflist<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    PyObject <span class="token operator">*</span>func_module<span class="token punctuation">;</span>    <span class="token comment">// 函数的 __module__, 可以是任何对象</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span> PyFunctionObject<span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>快速通道：python 为函数的执行提供了一个快速通道，常规的函数 <code>def func(arg1,arg2)</code> 可以通过快速通道执行，而 pythonic 形式的函数 <code>def func(*args,**kwargs)</code> 则无法通过快速通道执行。<ul><li>一般位置参数：（√）</li><li>其他：（×）</li></ul></li></ul><h3 id="函数参数实现"><a class="anchor" href="#函数参数实现">#</a> 函数参数实现</h3><h4 id="参数类别"><a class="anchor" href="#参数类别">#</a> 参数类别</h4><ul><li>位置参数：<ul><li>一般位置参数： <code>def func(arg1,arg2)</code></li><li>默认位置参数： <code>def func(arg1=1,arg2=2)</code></li></ul></li><li>键参数： <code>func(arg1=1,arg2=2)</code></li><li>扩展位置参数： <code>func(*args)</code></li><li>扩展键参数： <code>func(**kwargs)</code></li></ul><h4 id="参数数量"><a class="anchor" href="#参数数量">#</a> 参数数量</h4><ul><li>CALL_FUNCTION：通过 2 个字节标识参数数量，高字节表示键参数数量，低字节表示位置参数数量。所以函数最多可以有 256 个位置参数和 256 个键参数。值得注意，该问题在 python3.7 之后已经没有了。唯一限制数量的因素：<ul><li><code>list</code> ， <code>tuple</code> 和 <code>dict</code> 仅受限于 <code>sys.maxsize</code></li><li><code>*args</code> 和 <code>**kwargs</code> 仅受限于 <code>sys.maxint</code></li><li><code>*args</code> 和 <code>**kwargs</code> 都只占用一个参数数量，在编译时会被处理成 <code>PyListObject</code> 和 <code>PyDictObject</code></li></ul></li></ul><h4 id="参数位置"><a class="anchor" href="#参数位置">#</a> 参数位置</h4><p>函数参数和运行时栈的空间，在逻辑上是分离的，参数会被存放在 <code>f_localsplus</code> 中。而 PyFrameObject 则保存了 <code>f_localsplus</code> 的栈顶指针。</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200928174020983.png" alt="image-20200928174020983"></p><h4 id="扩展参数"><a class="anchor" href="#扩展参数">#</a> 扩展参数</h4><p>扩展参数申明后，会提供一个标记，用于函数读取参数时区分是否需要处理扩展参数：</p><ul><li>扩展位置参数：CO_VARARGS</li><li>扩展键参数：CO_VARKEYWORDS</li></ul><h3 id="函数内变量"><a class="anchor" href="#函数内变量">#</a> 函数内变量</h3><p>函数内的变量和函数参数类似，都是存放在 <code>f_localsplus</code> 中运行时栈前面的一段内存空间中</p><h3 id="嵌套-闭包-装饰器"><a class="anchor" href="#嵌套-闭包-装饰器">#</a> 嵌套、闭包、装饰器</h3><h4 id="嵌套函数"><a class="anchor" href="#嵌套函数">#</a> 嵌套函数</h4><ul><li>co_cellvars：通常是一个 tuple，保存嵌套作用域中使用到的变量名集合，存放在 <code>f_localsplus</code> 的 <code>内嵌对象</code> 中。</li><li>co_freevars：通常是一个 tuple，保存了使用外层作用域的变量名集合，存放在 <code>f_localsplus</code> 的 <code>外引对象</code> 中。</li></ul><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    i <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">in</span></pre></td></tr></table></figure><p>该嵌套函数中 <code>out</code> 函数中的 <code>co_cellvars</code> 内会保存 <code>i</code> 变量，同理 <code>in</code> 函数中的 <code>co_freevars</code> 内也会保存 <code>i</code> 变量。</p><h4 id="闭包closure"><a class="anchor" href="#闭包closure">#</a> 闭包（closure）</h4><p>当内层函数使用外层函数的变量的这种形式被称之为闭包，闭包的实现原理大致可以理解为：</p><ul><li>外层函数在执行过程中，会把自身运行栈中的变量以 <code>ob_ref</code> 的形式绑定到 <code>co_cellvars</code> 的 tuple 当中。<br><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200928212157054.png" alt="image-20200928212157054"></li><li>在需要向内层传递时，首先会创建一个内层函数的对象，存储在局部变量上 inner_func，并把 <code>co_cellvars</code> 的 tuple 链接到 inner_func 对象的 tuple 上。</li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200928212220150.png" alt="image-20200928212220150"></p><ul><li>最终，在 inner_func 对象内，解开传递进来的 <code>co_cellvars</code> 的 tuple 并重新绑定到自己的 <code>co_freevars</code> 的 tuple 中，便完成了整个闭包的参数传递过程</li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200928213023716.png" alt="image-20200928213023716"></p><h4 id="装饰器decorator"><a class="anchor" href="#装饰器decorator">#</a> 装饰器（decorator）</h4><p>装饰器本质上就是闭包的一个包装方式，原理和 closure 类似。</p><h2 id="python类机制"><a class="anchor" href="#python类机制">#</a> python 类机制</h2><ul><li><p>Python 中，任何对象都有一个 <code>type</code> ，可以通过 <code>__class__</code> 属性获得，任何一个 <code>instance</code> 对象的 <code>type</code> 都是一个 <code>class</code> 对象。任何一个 <code>class</code> 对象的 type 都是一个 metaclass 对象。大多数情况下 <code>metaclass</code> 对象通常是 <code>&lt;type 'type'&gt;</code> 。</p></li><li><p>Python 中，任何 class 对象都直接或间接与 <code>&lt;type 'object'&gt;</code> 存在 <code>is-kind-of</code> （基类与子类） 关系，包括 <code>&lt;type 'type'&gt;</code> 。</p></li></ul><h3 id="从-type-对象到-class-对象"><a class="anchor" href="#从-type-对象到-class-对象">#</a> 从 type 对象到 class 对象</h3><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyInt</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">__add__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">.</span>__add__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span></pre></td></tr></table></figure><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20201005115151224.png" alt="image-20201005115151224"></p><h4 id="可调用性callable"><a class="anchor" href="#可调用性callable">#</a> 可调用性（callable)</h4><p>只要一个对象实现了 <code>__call__</code> 操作，本质是是 Python 内部的 PyTypeObject 中的 <code>tp_call</code> 不为空，那就其就是一个可调用对象</p><h4 id="step1-处理基类class__base__和-type-信息"><a class="anchor" href="#step1-处理基类class__base__和-type-信息">#</a> Step.1 处理基类 ( <code>class.__base__</code> ) 和 Type 信息</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">PyType_Ready</span><span class="token punctuation">(</span>PyTypObject <span class="token operator">*</span>type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    PyObject <span class="token operator">*</span>dict <span class="token operator">*</span>bases<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    PyTypeObject <span class="token operator">*</span>base<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    Py_ssize_t i<span class="token punctuation">,</span>n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">//「1」：尝试获得 type 的 tp_base 中的指定基类。</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    base <span class="token operator">=</span> type <span class="token operator">-></span>tp_base<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>base <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> type <span class="token operator">!=</span> <span class="token operator">&amp;</span>PyBaseObject_Type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        base <span class="token operator">=</span> type<span class="token operator">-></span>tp_base <span class="token operator">=</span> <span class="token operator">&amp;</span>PyBaseObject_Type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">//「2」：没有初始化基类的话，初始化基类</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>base <span class="token operator">&amp;&amp;</span> base<span class="token operator">-></span>tp_dict <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">PyType_Ready</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    </pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">//「3」：设置 type 信息</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">-></span>ob_type <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> base <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        type<span class="token operator">-></span>ob_type <span class="token operator">=</span> base<span class="token operator">-></span>ob_type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>部分内置函数的 tp_base 信息，NULL 的话则默认为 <code>&lt;type 'object'&gt;(PyBaseObject_Type)</code></p></blockquote><table><thead><tr><th>class 对象</th><th>基类信息</th></tr></thead><tbody><tr><td>PyType_Type</td><td>NULL</td></tr><tr><td>PyInt_Type</td><td>NULL</td></tr><tr><td>PyBool_Type</td><td>&amp;PyInt_Type</td></tr></tbody></table><h4 id="step2-处理基类列表class-__bases__"><a class="anchor" href="#step2-处理基类列表class-__bases__">#</a> Step.2 处理基类列表 ( <code>class .__bases__</code> )</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">PyType_Ready</span><span class="token punctuation">(</span>PyTypObject <span class="token operator">*</span>type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token comment">//「4」： 处理基类列表</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    bases <span class="token operator">=</span> type<span class="token operator">-></span>tp_bases<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>bases <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>base <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            bases <span class="token operator">=</span> <span class="token function">PyTuple_New</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            bases <span class="token operator">=</span> <span class="token function">PyTuple_Pack</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        type<span class="token operator">-></span>tp_bases <span class="token operator">=</span> bases<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="step3-填充-tp_dictclass-__dict__"><a class="anchor" href="#step3-填充-tp_dictclass-__dict__">#</a> Step.3 填充 tp_dict ( <code>class .__dict__</code> )</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">PyType_Ready</span><span class="token punctuation">(</span>PyTypObject <span class="token operator">*</span>type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token comment">//「5」： 设定 tp_dict</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    dict <span class="token operator">=</span> type<span class="token operator">-></span>tp_dict<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dict <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        dict <span class="token operator">=</span> <span class="token function">PyDict_New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        type<span class="token operator">-></span>tp_dict <span class="token operator">=</span> dict<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">//「6」： 将与 type 相关的 descriptor 加入到 tp_dict 中</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">add_operation</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">-></span>tp_methods <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token function">add_methods</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> type<span class="token operator">-></span>tp_methods<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">-></span>tp_members <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token function">add_members</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> type<span class="token operator">-></span>tp_members<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token operator">-></span>tp_getset <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token function">add_getset</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> type<span class="token operator">-></span>tp_getset<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="step4-对-slot-排序并关联到-descriptor"><a class="anchor" href="#step4-对-slot-排序并关联到-descriptor">#</a> Step.4 对 slot 排序并关联到 descriptor</h4><ul><li><p>每个 <code>descriptor</code> 对应与一个 <code>slot</code> 。一个 <code>slot</code> 对应一个 <code>func</code> 。而每个函数又通过函数名和 <code>descriptor</code> 指针被关联在 <code>PyTypeObject</code> 对象中的 <code>tp_dict</code> 内。</p></li><li><p>如果出现一个函数名对应多个 <code>slot</code> 的情况下时。 <code>slot</code> 排序可以解决最终调用哪个的问题。排序规则则是根据 <code>offset</code> 大小来决定的， <code>offset</code> 小的优先级更高。 例如两个同名函数，一个在 <code>PyHeadObject</code> 的 <code>PyNumberMethods</code> 结构中，另一个则在 <code>PyMappingMethods</code> 中，那么 <code>PyNumberMethods</code> 中的将被调用。</p></li><li><p>调用函数时，会先在 <code>PyTypeObject</code> 的 <code>tp_dict</code> 内进行查找，根据函数名找到对应的 <code>descriptor</code> ，并调用 <code>descriptor</code> 的 <code>wrapperdescr_call</code> 调用 <code>slot</code> 所关联的 <code>func</code></p></li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20201005144210081.png" alt="image-20201005144210081"></p><blockquote><p>slot 结构</p></blockquote><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">slotdef</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">// 函数名称</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> offset<span class="token punctuation">;</span> <span class="token comment">// 相对于 PyHeadObject 的偏移量</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">void</span> <span class="token operator">*</span>function<span class="token punctuation">;</span> <span class="token comment">//slot 的 function</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    wrapperfunc wrapper<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>doc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> flags<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    PyObject <span class="token operator">*</span>name_strobj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>descriptor 结构</p></blockquote><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">PyWrapperDescrObject</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    PyObject_HEAD</pre></td></tr><tr><td data-num="3"></td><td><pre>    PyTypeObject <span class="token operator">*</span>d_type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    PyObject <span class="token operator">*</span>d_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">slotdef</span> <span class="token operator">*</span>d_base<span class="token punctuation">;</span> <span class="token comment">//slot 对象</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">void</span> <span class="token operator">*</span>d_wrapped<span class="token punctuation">;</span> <span class="token comment">// 关联的函数指针</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>PyHeadTypeObject 结构</p></blockquote><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">PyHeadObject</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    PyTypeObject ht_type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    PyNumberMethods as_number<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    PyMappingMethods as_mapping<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    PySequenceMethods as_sequence<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    PyBufferProcs as_buffer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    PyObject <span class="token operator">*</span>ht_name<span class="token punctuation">,</span> <span class="token operator">*</span>ht_slots<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="step5-确定mro列表"><a class="anchor" href="#step5-确定mro列表">#</a> Step.5 确定 mro 列表</h3><p>mro 的 C3 超类线性化算法：<br>算法思想：</p><ul><li>对象父类的集合 <code>「L(自己)」</code> 可以视作 <code>「自己」</code> + 每个 <code>「L(父类)」</code> + <code>「父类集合」</code></li><li>在存在多个父类合并的情况下，优先提取出第一个集合中的第一个元素与其他集合进行比对，如果其同时出现在其他集合的 <code>非第一的位置</code> 则跳至下一个集合重复上述操作。否则则把该元素添加至父类列表，并从其余所有集合中移除，完成后再次从第一个集合提取第一个元素重复上述内容。</li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/Image(16).png" alt="773d44c1b5451bd76a106d69574a2fdf.png"></p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>L<span class="token punctuation">(</span>O<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>L<span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token punctuation">[</span>C<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>L<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token punctuation">[</span>A<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>L<span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token punctuation">[</span>B<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>L<span class="token punctuation">(</span>D<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token punctuation">[</span>D<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre>L<span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token punctuation">[</span>E<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>L<span class="token punctuation">(</span>K1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span>K1<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token operator">+</span> L<span class="token punctuation">(</span>C<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token operator">+</span> L<span class="token punctuation">(</span>A<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token operator">+</span> L<span class="token punctuation">(</span>B<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>C<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="13"></td><td><pre>        </pre></td></tr><tr><td data-num="14"></td><td><pre> L<span class="token punctuation">(</span>K1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span>K1<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>C<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>A<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>B<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>C<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">]</span>      </pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>L<span class="token punctuation">(</span>K1<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span>K1<span class="token punctuation">,</span>C<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="21"></td><td><pre>L<span class="token punctuation">(</span>K2<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span>K2<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="22"></td><td><pre>L<span class="token punctuation">(</span>K3<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span>K3<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">,</span>E<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>L<span class="token punctuation">(</span>Z<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span>Z<span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token operator">+</span>L<span class="token punctuation">(</span>K1<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token operator">+</span> L<span class="token punctuation">(</span>K3<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token operator">+</span> L<span class="token punctuation">(</span>K2<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>K1<span class="token punctuation">,</span>K2<span class="token punctuation">,</span>K3<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="29"></td><td><pre>L<span class="token punctuation">(</span>Z<span class="token punctuation">)</span><span class="token operator">=</span>  <span class="token punctuation">[</span>Z<span class="token punctuation">]</span> </pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>K1<span class="token punctuation">,</span>C<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>K2<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>K3<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">,</span>E<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>K1<span class="token punctuation">,</span>K2<span class="token punctuation">,</span>K3<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="34"></td><td><pre>L<span class="token punctuation">(</span>Z<span class="token punctuation">)</span> <span class="token operator">=</span>  <span class="token punctuation">[</span>Z<span class="token punctuation">,</span>K1<span class="token punctuation">,</span>K2<span class="token punctuation">,</span>K3<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>C<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>B<span class="token punctuation">,</span>D<span class="token punctuation">,</span>E<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="38"></td><td><pre> L<span class="token punctuation">(</span>Z<span class="token punctuation">)</span> <span class="token operator">=</span>  <span class="token punctuation">[</span>Z<span class="token punctuation">,</span>K1<span class="token punctuation">,</span>K2<span class="token punctuation">,</span>K3<span class="token punctuation">,</span>C<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">,</span>E<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>O<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token operator">+</span> <span class="token punctuation">[</span>O<span class="token punctuation">]</span>       </pre></td></tr><tr><td data-num="42"></td><td><pre> L<span class="token punctuation">(</span>Z<span class="token punctuation">)</span> <span class="token operator">=</span>  <span class="token punctuation">[</span>Z<span class="token punctuation">,</span>K1<span class="token punctuation">,</span>K2<span class="token punctuation">,</span>K3<span class="token punctuation">,</span>C<span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>D<span class="token punctuation">,</span>E<span class="token punctuation">,</span>O<span class="token punctuation">]</span></pre></td></tr></table></figure><h4 id="step6-继承基类操作"><a class="anchor" href="#step6-继承基类操作">#</a> Step.6 继承基类操作</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">PyType_Ready</span><span class="token punctuation">(</span>PyTypObject <span class="token operator">*</span>type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">//「7」： 拷贝基类操作到子类</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    bases <span class="token operator">=</span> type<span class="token operator">-></span>tp_mro<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    n <span class="token operator">=</span> <span class="token function">PyTuple_GET_SIZE</span><span class="token punctuation">(</span>bases<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        PyObject <span class="token operator">*</span>b <span class="token operator">=</span><span class="token function">PyTuple_GET_ITEM</span><span class="token punctuation">(</span>bases<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">inherit_slots</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token punctuation">(</span>PyTypeObject <span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="step7-填充子类列表class__subclasses__"><a class="anchor" href="#step7-填充子类列表class__subclasses__">#</a> Step.7 填充子类列表（ <code>class.__subclasses__()</code> ）</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">PyType_Ready</span><span class="token punctuation">(</span>PyTypObject <span class="token operator">*</span>type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">//「8」： 填充子类列表</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    bases <span class="token operator">=</span> type<span class="token operator">-></span>tp_mro<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    n <span class="token operator">=</span> <span class="token function">PyTuple_GET_SIZE</span><span class="token punctuation">(</span>bases<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        PyObject <span class="token operator">*</span>b <span class="token operator">=</span><span class="token function">PyTuple_GET_ITEM</span><span class="token punctuation">(</span>bases<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">add_subclass</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PyTypeObject <span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 填充</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="自定义-class"><a class="anchor" href="#自定义-class">#</a> 自定义 class</h3><ul><li><p>创建 class 对象</p><ul><li>获取动态元信息 ——class 的动态属性（属性，函数）</li><li>获取静态元信息 ——class 的类型，空间大小（通过查看 <code>_metaclass__</code> 属性来获取静态元信息，默认情况下是获取 <code>&lt;type 'type'&gt;</code> 的静态元信息）<br><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20201005153723438.png" alt="image-20201005153723438"></li><li>用户自定义 class 对象和内置 class 对象的区别在于：<ul><li>用户自定义对象的内存排列是<strong>连续</strong>的</li><li>内置 class 对象的内存排列是<strong>分散</strong>的<br><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20201005154812793.png" alt="image-20201005154812793"></li></ul></li></ul></li><li><p>创建 class 对象的 instance</p><ul><li><code>instance = class.__new__(class, args, kwds)</code></li><li><code>class.__init__(instance, args, kwds)</code></li></ul></li></ul><h4 id="descriptor介绍"><a class="anchor" href="#descriptor介绍">#</a> descriptor 介绍</h4><p><code>descriptor</code> 像是一个连接属性名称和属性值的一个接口。提供一套访问属性的方法。外部通过 <code>descriptor</code> 来对属性进行访问。</p><ul><li>实现了 <code>__get__</code> 、 <code>__set__</code> 、 <code>__delete__</code> 函数的 obj 被称之为 <code>descriptor</code></li><li><code>descriptor</code> 影响着 <code>class</code> 和 <code>instance</code> 对于属性的获取规则<ul><li>有 <code>__get__</code> 和 <code>__set__</code> 的被称为 <code>data descriptor</code></li><li>有 <code>__get__</code> 无 <code>__set__</code> 的被称为 <code>no data descriptor</code></li></ul></li><li>属性选择的规则：<ul><li>先 <code>instance</code> 的属性，后 <code>class</code> 的属性。</li><li>如果 <code>instance</code> 和 <code>class</code> 中有同名属性，且 <code>class</code> 的属性是 <code>data descriptor</code> ，那么会选择使用 <code>class</code> 的属性。</li><li>当获取到的属性是一个 <code>descriptor</code> 的时候，如果其存在于 <code>class</code> 的 <code>tp_dict</code> 中会调用其 <code>__get__</code> 函数获取对应的属性值，如果其存在于 <code>instance</code> 的 <code>tp_dict</code> 中则不会调用其 <code>__get__</code> 属性。</li></ul></li></ul><h4 id="bound-method-和-unbound-method"><a class="anchor" href="#bound-method-和-unbound-method">#</a> Bound Method 和 Unbound Method</h4><p>两者的本质区别是一个函数的调用是否有默认参数 self。如果有，则在每次函数调用过程中，虚拟机会自动执行一次函数绑定，把 instance 和 self 进行关联。否则，需要程序自己手动传参。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        </pre></td></tr><tr><td data-num="5"></td><td><pre>a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>a<span class="token punctuation">.</span>test<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 自动绑定</span></pre></td></tr><tr><td data-num="7"></td><td><pre>A<span class="token punctuation">.</span>test<span class="token punctuation">(</span>A<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 手动传参</span></pre></td></tr></table></figure><blockquote><p>减少函数绑定的次数可以提高程序的执行效率</p></blockquote><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>func <span class="token operator">=</span> a<span class="token punctuation">.</span>test <span class="token comment">#绑定 1 次</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    func<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    a<span class="token punctuation">.</span>test<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#绑定 1000 次</span></pre></td></tr></table></figure><h2 id="python运行环境初始化"><a class="anchor" href="#python运行环境初始化">#</a> python 运行环境初始化</h2><h3 id="初始化线程环境"><a class="anchor" href="#初始化线程环境">#</a> 初始化线程环境</h3><ul><li>初始化 python 多进程</li><li>初始化 python 多线程</li></ul><h4 id="进程结构"><a class="anchor" href="#进程结构">#</a> 进程结构：</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 进程对象结构</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">PyInterpreterState</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">_is</span> <span class="token operator">*</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">_ts</span> <span class="token operator">*</span>tstate_head<span class="token punctuation">;</span> <span class="token comment">// 模拟线程集合</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    PyObject <span class="token operator">*</span>modules<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    PyObject <span class="token operator">*</span> sysdict<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    PyObject <span class="token operator">*</span>builtins<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="线程结构"><a class="anchor" href="#线程结构">#</a> 线程结构：</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 线程对象结构</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">PythreadState</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">_ts</span> <span class="token operator">*</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    PyInterpreterState <span class="token operator">*</span>interp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">_frame</span> <span class="token operator">*</span>frame<span class="token punctuation">;</span> <span class="token comment">// 模拟函数调用栈</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> recursion_depth<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    PyObject <span class="token operator">*</span>dict<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">long</span> thread_id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20201007145711667.png" alt="image-20201007145711667" title="Python 运行时整体环境"></p><h3 id="加载系统module"><a class="anchor" href="#加载系统module">#</a> 加载系统 module</h3><h4 id="创建__builtin__-module"><a class="anchor" href="#创建__builtin__-module">#</a> 创建 <code>__builtin__</code> module</h4><p>一个进程内的全部线程共享一个 <code>&lt;module __builtin__&gt;</code></p><ul><li>创建 module 对象</li><li>设置 module 对象</li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20201007151250252.png" alt="image-20201007151250252" title="初始化完成的 __builtin__ module"></p><h4 id="创建-sys-module"><a class="anchor" href="#创建-sys-module">#</a> 创建 sys module</h4><ul><li>创建 sys module 并备份</li><li>设置 moduel 搜索路径</li><li>创建 <code>__main__</code> module</li><li>设置 site-specific 的 module 搜索路径（第三方库）<ul><li>核心实现在 <span class="exturl" data-url="aHR0cDovL3NpdGUucHk=">site.py</span> 中：<ul><li>site 会将 site-packages 加入到 sys.path</li><li>把 site-packages 下的所有 .pth 文件加入到 sys.path 中</li></ul></li></ul></li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20201007154617538.png" alt="image-20201007154617538" title="完成初始化后的环境"></p><blockquote><p>extensions 用于缓存模块，再次加载的时候可以提高效率。</p></blockquote><h3 id="激活虚拟机"><a class="anchor" href="#激活虚拟机">#</a> 激活虚拟机</h3><h4 id="交互式运行方式"><a class="anchor" href="#交互式运行方式">#</a> 交互式运行方式</h4><ul><li>把用户输入构造成 python 的 AST 语法树</li><li>执行 run_mode 运行语法树</li></ul><h4 id="脚本文件运行方式"><a class="anchor" href="#脚本文件运行方式">#</a> 脚本文件运行方式</h4><ul><li>编译脚本文件</li><li>执行 run_mode 运行编译后的脚本文件</li></ul><h4 id="启动虚拟机"><a class="anchor" href="#启动虚拟机">#</a> 启动虚拟机</h4><ul><li>run_mode 内会启动 Python 字节码虚拟机。之后循环往复的执行字节码。</li></ul><h4 id="名字空间"><a class="anchor" href="#名字空间">#</a> 名字空间</h4><ul><li>local、global、bulitin 的设置。</li><li>交互环境下 local 名字空间内不会有 <code>__file__</code> 属性</li><li>Python 所有的线程都共享同样的 builtin 名字空间</li></ul><h2 id="python模块动态加载机制"><a class="anchor" href="#python模块动态加载机制">#</a> python 模块动态加载机制</h2><h3 id="import-机制"><a class="anchor" href="#import-机制">#</a> import 机制</h3><ul><li><code>import module/package</code> ： <code>import</code> 操作会先在全局模块池（ <code>sys.module</code> ）中搜索 <code>module</code> 或 <code>package</code> 。如果以及存在，则直接加入当前 <code>module</code> 的 <code>local</code> 名字空间，否则就添加到 <code>sys.module</code> 和 <code>local</code> 。</li><li><code>import package.module</code> ：和 <code>import module/package</code> 类似，不过会额外把 <code>package</code> 加入到 <code>sys.module</code> 中。但不会加入 <code>local</code> 名字空间。</li><li><code>import package.module as xx</code> ：和 <code>import package.module</code> 类似。这里会对 <code>package.module</code> 在 <code>local</code> 名字空间做一个映射，实际的 <code>sys.module</code> 中引入的还是 <code>package.module</code> 。但是在 <code>local</code> 中其表示为 <code>xx</code> 。</li><li><code>from package.module import xx</code> ：和 <code>import package.module as xx</code> 类似。会在 <code>sys.module</code> 引入 <code>package</code> 和 <code>package.module</code> ，同时在 <code>local</code> 引入 <code>xx</code> 。</li><li>嵌套的 <code>import</code> ：一个模块 import 另一个模块的情况下。每个模块的 import 都会影响 <code>sys.module</code> 和自身的 <code>local</code> 名字空间。但不会影响其他模块的 <code>local</code> 。</li></ul><h3 id="模块销毁与重载"><a class="anchor" href="#模块销毁与重载">#</a> 模块销毁与重载</h3><h4 id="销毁"><a class="anchor" href="#销毁">#</a> 销毁</h4><p>Python 提供了 <code>del module/package</code> 操作用于销毁模块。但是销毁的只是当前 <code>local</code> 名字空间内的， <code>sys.module</code> 中依旧保存了其缓存。所以单纯的 <code>del module</code> ，再 <code>import module</code> 并不能实现热更新。</p><h4 id="重载"><a class="anchor" href="#重载">#</a> 重载</h4><p>Python 提供了 <code>reload module</code> 操作用于重载模块。 <code>reload</code> 操作可以更新 <code>sys.module</code> 中的模块信息，把一些新增和修改的内容加入到 <code>module</code> 中，但是对于需要删除的内容，则无能为力，依旧会缓存在 <code>module</code> 内。</p><h3 id="import-实现机制"><a class="anchor" href="#import-实现机制">#</a> import 实现机制</h3><p>import 的实现核心是依靠其 <code>builtin</code> 模块内的 <code>__import__</code> 操作。即： <code>builtin__import__</code> 函数。</p><ul><li>调用 <code>builtin__import__</code> 函数，解析传递进来的参数。</li><li>上锁。避免不同线程同时操作一个 <code>module</code> 。</li><li>解析 <code>module/package</code> 树状结构。<ul><li>Python 的所有搜索操作（ <code>import xxx/from xxx import xxx</code> ）都是基于某一个 <code>package</code> 来的。换句话说，所有查找的根目录（ <code>__main__</code> ) 都是一致的。即：某个 <code>package</code> 的路径。</li><li>Python 的搜索操作是不能搜索根目录之上的模块，例如：</li></ul></li></ul><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 如果是基于 Package——A，那么可以访问到所有模块。根路径:/A = __main__.path</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 如果是基于 Package——B，那么无法访问 C 模块和 A 模块下的内容。根路径:/A/B = __main__.path</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 如果是基于 Package——C，那么无法访问 B 模块和 A 模块下的内容。根路径:/A/C = __main__.path</span></pre></td></tr><tr><td data-num="4"></td><td><pre>A</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">|</span>——__init__<span class="token punctuation">.</span>py</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token operator">|</span>——B</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token operator">|</span>  <span class="token operator">|</span>——__init__<span class="token punctuation">.</span>py</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token operator">|</span>  <span class="token operator">|</span>——test1<span class="token punctuation">.</span>py</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token operator">|</span>  <span class="token operator">|</span>——test2<span class="token punctuation">.</span>py</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token operator">|</span>——C</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token operator">|</span>  <span class="token operator">|</span>——__init__<span class="token punctuation">.</span>py</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token operator">|</span>  <span class="token operator">|</span>——test3<span class="token punctuation">.</span>py</pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token operator">|</span>  <span class="token operator">|</span>——test4<span class="token punctuation">.</span>py</pre></td></tr></table></figure><ul><li>加载 <code>module/package</code><ul><li><p>先在 <code>sys.module</code> 中搜索是否依旧有加载过该模块留下的缓存了。</p></li><li><p>尝试加载 <code>source module</code> 。如果没有则对 <code>.py</code> 文件进行编译，生成所需的 <code>PyCodeObject</code> 。</p></li><li><p>如果需要加载内建 module。则会先去内建 module 备份列表中确认是否以及加载过了。再执行加载操作。</p></li><li><p>加载 C 扩展的 module。</p><ul><li>window：dll 文件</li><li>linux：so 文件</li><li>不论哪种平台，都需要遵循 Python 执行的一套导入规则，格式大致如下：</li></ul><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 申明一个 PyMethodObject 对象所需的参数信息</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> PyMethodDef test_methods<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">&#123;</span><span class="token string">"hello"</span><span class="token punctuation">,</span> Hello<span class="token punctuation">,</span> METH_VARARGS<span class="token punctuation">,</span> <span class="token string">"say hello"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 对应下方图片内红框内容</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token punctuation">&#123;</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 告知 Python 初始化模块：模块名 模块信息</span></pre></td></tr><tr><td data-num="8"></td><td><pre>EXPORT <span class="token keyword">int</span> <span class="token function">initest</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token function">Py_InitModule</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> test_methods<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>细心的同学可以发现，这和内建模块的导入规则几乎一致</li></ul></li></ul></li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20201007210412440.png" alt="image-20201007210412440" title="完成初始化后的环境"></p><ul><li><code>from xxx import m,n</code> ：该操作会判断 xxx 模块中是否存在 m 和 n，而判断的依据就是通过 <code>__all__</code> 来实现的。如果没有申明 <code>__all__</code> ，那么则会使用 Python 默认的 <code>PyObject_GetAttrString</code> 函数来获取模块下的所有内容。否则，则会以 <code>__all__</code> 列表里的内容为准。</li></ul><h3 id="legb-规则"><a class="anchor" href="#legb-规则">#</a> LEGB 规则</h3><blockquote><p>Local -&gt; Enclosed -&gt; Global -&gt; Built-in</p></blockquote><ul><li><code>Local</code> ：可能是在一个函数或者类方法内部。</li><li><code>Enclosed</code> ： 可能是嵌套函数内，比如说 一个函数包裹在另一个函数内部。</li><li><code>Global</code> ：代表的是执行脚本自身的最高层次。</li><li><code>Built-in</code> ：是 Python 为自身保留的特殊名称。</li></ul><h3 id="最内嵌作用域-规则"><a class="anchor" href="#最内嵌作用域-规则">#</a> 最内嵌作用域 规则</h3><p>由一个赋值语句引进的名字在这个赋值语句所在的作用域里是可见（起作用）的，而且在其内部嵌套的每个作用域里也可见。</p><blockquote><p>除非它被嵌套于内部的，引进同样名字的另一条赋值语句所遮蔽 / 覆盖。</p></blockquote><ul><li>eg：</li></ul><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>module2<span class="token punctuation">.</span>py<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a <span class="token operator">=</span> <span class="token number">50</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">[</span>module1<span class="token punctuation">.</span>py<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">import</span> module2</pre></td></tr><tr><td data-num="8"></td><td><pre>a <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment"># module1 申明的 a 在 module2 中是可见的</span></pre></td></tr><tr><td data-num="9"></td><td><pre>module2<span class="token punctuation">.</span>test<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#执行过程中 module2 里的 a 覆盖了 global 作用域中 module1 里的 a</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>Out<span class="token punctuation">:</span><span class="token number">50</span></pre></td></tr></table></figure><h2 id="python多线程机制"><a class="anchor" href="#python多线程机制">#</a> python 多线程机制</h2><h3 id="gil全局解释器锁和线程调度"><a class="anchor" href="#gil全局解释器锁和线程调度">#</a> GIL (全局解释器锁) 和线程调度</h3><p>在 Python 多线程中，不同线程之间会访问一些共享的资源，例如对象的引用计数和对象的释放。如果同时有两个线程修改一个对象的引用计数，导致对象被释放，那么可能会出现对象释放多次的问题。这时 <code>GIL</code> 就应运而生了。</p><ul><li><code>GIL</code> ：本质上是一个解释器，只有当线程拥有该解释器的访问权限时，才能够执行指令。 <code>GIL</code> 间接的把多处理器的多线程模型转变为了单处理器的多线程模型。虽然其看上去对于锁的粒度较大，但在实际使用中效果却意外的好用。</li><li>线程调度：<ul><li>中断机制：Python 的中断机制和操作系统类似，都是模拟 <code>时钟中断</code> 。会根据执行的指令数目来控制线程中断，在 Python 2.5 中，默认执行 100 条指令后，会触发线程的中断，切换到其他线程。</li><li>唤醒机制：对于需要唤醒哪个线程，Python 层面没有过多的干涉，而是把该任务交给了操作系统。</li><li>Python 提供的两个多线程工具：<ul><li>thread：C 实现的 builtin module。</li><li>threading：Python 实现的标准库 module。</li></ul></li></ul></li></ul><h3 id="python线程的创建"><a class="anchor" href="#python线程的创建">#</a> Python 线程的创建</h3><p>Python 虚拟机默认情况下是不支持多线程的，即：用户如果没有手动调用 <code>thread.start_new_thread</code> 接口，Python 则不会创建多线程相关的对象，也不会触发线程调度。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> PyObject<span class="token operator">*</span> <span class="token function">thread_PyThread_start_new_thread</span><span class="token punctuation">(</span>PyObject <span class="token operator">*</span>self<span class="token punctuation">,</span> PyObject <span class="token operator">*</span>fargs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    PyObject <span class="token operator">*</span>func<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">*</span>keyw <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">bootstate</span> <span class="token operator">*</span>boot<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">long</span> ident<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">PyArg_UnpackTuple</span><span class="token punctuation">(</span>fargs<span class="token punctuation">,</span> <span class="token string">"start_new_thread"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>func<span class="token punctuation">,</span> <span class="token operator">&amp;</span>args<span class="token punctuation">,</span> <span class="token operator">&amp;</span>keyw<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 「1」: 创建 bootstate 结构</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    boot <span class="token operator">=</span> <span class="token function">PyMem_NEW</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bootstate</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    boot<span class="token operator">-></span>interp <span class="token operator">=</span> <span class="token function">PyThreadState_GET</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>interp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    boot<span class="token operator">-></span>func <span class="token operator">=</span> func<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    boot<span class="token operator">-></span>args <span class="token operator">=</span> args<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    boot<span class="token operator">-></span>keyw <span class="token operator">=</span> keyw<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 「2」: 初始化多线程环境</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">PyEval_InitThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 「3」: 创建子线程</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    ident <span class="token operator">=</span> <span class="token function">PyThread_start_new_thread</span><span class="token punctuation">(</span>t_bootstrap<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> boot<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">PyInt_FromLong</span><span class="token punctuation">(</span>ident<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>创建线程主要分为三个步骤：</p><ul><li>创建并初始化 bootstate 结构 boot，boot 中保存了线程的过程和过程的参数。</li><li>初始化 Python 的多线程环境。</li><li>以 boot 为参数，创建操作系统的原生线程。</li></ul><h4 id="建立多线程环境"><a class="anchor" href="#建立多线程环境">#</a> 建立多线程环境</h4><ul><li>创建 GIL，以下是 GIL 的结构</li></ul><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">NRMUTEX</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    LONG owned<span class="token punctuation">;</span> <span class="token comment">//GIL 是否可获得，或是被占用 -1: 可用 0: 被占用</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    DWORD thread_id<span class="token punctuation">;</span> <span class="token comment">// 线程 id</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    HANDLE hevent<span class="token punctuation">;</span> <span class="token comment">// 操作系统的 Event 对象</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>线程每次需要执行前，必须获取 GIL，通过 <code>PyThread_acquire_lock</code> 函数。 <code>PyThread_acquire_lock</code> 有两种工作方式：<ul><li>当无法获得 GIL 时，挂起自身。</li><li>无法获得 GIL 时，不挂起。</li></ul></li></ul><h5 id="子线程的创建步骤"><a class="anchor" href="#子线程的创建步骤">#</a> 子线程的创建步骤</h5><ol><li>创建 bootstate 结构。</li><li>初始化多线程环境（主线程获得 GIL 控制权）。</li><li>创建子线程，同时挂起主线程，子线程开始完成 bootstrap 线程过程。<strong>这里的主线程挂起，子线程执行线程过程的操作不在 Python 中断的范畴，而是利用了操作系统本身的中断机制。所以子线程不需要获取 GIL 的控制权</strong>。</li><li>完成之后获得 thread_id，并设置 Semaphore，返回 thread_id ，挂起自身，并唤醒主线程。</li><li>主线程获得子线程的 thread_id，并开始和子线程争夺 GIL 的控制权（通过 <code>时钟中断</code> ）。<strong>此时，主线程和子线程的中断才完全依赖 GIL 的控制权控制。</strong></li><li>当子线程获得 GIL 控制权，主线程请求 GIL 被占用时，主线程挂起自身，子线程开始执行，当子线程执行完全部内容后，将被释放。到此，子线程的生命周期就已经结束。</li></ol><blockquote><p>在子线程没有完全的创建完毕前（第 4 步没有执行完毕），中断机制不受 GIL 控制。</p><p>线程自身的挂起状态，不是在归还 GIL 控制权后发生，而是在请求 GIL 无果后发生。</p></blockquote><h5 id="线程状态保护机制"><a class="anchor" href="#线程状态保护机制">#</a> 线程状态保护机制</h5><p>为了能够快速访问线程的状态，获取每个线程的信息，Python 为线程状态链表单独实现了一套锁机制，并且线程状态链表的访问不受 GIL 控制。</p><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20201008133920825.png" alt="image-20201008133920825" title="线程状态对象链表"></p><h3 id="python线程调度"><a class="anchor" href="#python线程调度">#</a> Python 线程调度</h3><h4 id="标准调度"><a class="anchor" href="#标准调度">#</a> 标准调度</h4><p>通过字节码计数来触发中断，默认情况下线程每执行 100 条字节码指令，就会触发一次中断。但在 Python 程序中，某些指令的执行不会计算字节码执行次数。</p><h4 id="阻塞调度"><a class="anchor" href="#阻塞调度">#</a> 阻塞调度</h4><p>阻塞调度和标准调度有所不同，标准调度的中断触发是被动的，而阻塞调度的中断触发则是主动的，即：线程主动归还 GIL 的控制权。且诸塞调度完成后不会把字节码指令数重置成 100。</p><p>此外相比于标准调度在切换线程时的连续性，阻塞调度在主动归还 GIL 到下次某个线程获得 GIL 的中间段，是会有一个空窗期的，这段时间内，线程将脱离 GIL 的控制，不过好在这段时间内，没有涉及到 Python 的 C API 调用，所以是线程安全的。</p><h3 id="python子线程的销毁"><a class="anchor" href="#python子线程的销毁">#</a> Python 子线程的销毁</h3><p>线程的销毁会释放其占用的 GIL 以及一些线程资源和维护的线程状态链表对象。</p><p>此外，主线程的销毁同时也会销毁 Python 的运行时环境，而子线程则不会。</p><h3 id="python线程的用户级互斥与同步"><a class="anchor" href="#python线程的用户级互斥与同步">#</a> Python 线程的用户级互斥与同步</h3><h4 id="lock-对象"><a class="anchor" href="#lock-对象">#</a> Lock 对象</h4><p>Python 的 Lock 分为系统级的 Lock——GIL 和 用户级 Lock。</p><p>当线程被唤醒时，首先会获得系统级的 Lock (GIL) 的控制权，之后会尝试获取用户级 lock，如果用户级 lock 被占用，则线程会归还系统级控制权，避免死锁。</p><h4 id="高级线程库threading"><a class="anchor" href="#高级线程库threading">#</a> 高级线程库 ——threading</h4><h4 id="threading-module-概述"><a class="anchor" href="#threading-module-概述">#</a> Threading Module 概述</h4><p>threading module 维护了两个 dict 和一个 lock：</p><ul><li>准备创建的线程字典： <code>_limbo[thread] = thread</code></li><li>已经创建的线程字典： <code>_active[thread_id] = thread</code></li><li>访问线程状态链表的锁： <code>_active_limbo_lock</code></li></ul><h4 id="threading-的线程同步工具"><a class="anchor" href="#threading-的线程同步工具">#</a> Threading 的线程同步工具</h4><ul><li><p><code>RLock</code> ：正常的 lock 一个 acquire 对应于 一个 release，如果同时执行两个 acquire 而不 release，则会出现死锁。RLock 则提供了可用多次 acquire 后再多次 release 操作的机制。不必每次借钱之前都得把上次欠的还清，可以先借多次，再还多次。</p></li><li><p><code>Condition</code> ：本质上时一个 <code>Lock</code> 对象，默认情况下是 <code>RLock</code> ，提供了 <code>wait</code> 和 <code>notify</code> 操作，可用在别的线程中主动唤醒其他线程。</p><ul><li><code>ConditionA.wait</code> ：A 线程调用时，释放 <code>ConditonA</code> 中的 <code>Lock</code> 并挂起线程 A。</li><li><code>ConditionA.notify</code> ：其他线程调用时，获得 <code>ConditonA</code> 中的 <code>Lock</code> 并唤醒线程 A。</li></ul></li><li><p><code>Semaphore</code> ：类似信号量，实现机制也是基于 <code>Lock</code> ，内部维护一个 <code>Conidtion</code> 对象，但与 Lock 的互斥不同，其可以支持多个线程获得资源。资源池的概念。</p></li><li><p><code>Event</code> ：和 Semaphore 类型，提供 <code>set</code> 和 <code>wait</code> 语义。</p></li></ul><h2 id="python的垃圾回收gc"><a class="anchor" href="#python的垃圾回收gc">#</a> python 的垃圾回收 GC</h2><h3 id="block"><a class="anchor" href="#block">#</a> block</h3><ul><li>用于存放对象的最小单位。</li><li>针对不同 size 的数据进行分类存储的块。数据大小为 8 的整数倍，最大为 256 字节。</li><li>如果内存大小≤256，则 python 会通过 PyObject_Malloc 去分配。如果 &gt; 256 字节，则会使用 malloc 来分配内存。</li><li>size 有 32 种（0~31）之后的版本扩充到了 63（512 字节）。</li><li>给对象分配的空间一般会超过原本大小，向上取 8 的整数倍。</li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/Image(68).png" alt="c87bfa632b2c7e3254911863fbe36e55.png"></p><h3 id="pool"><a class="anchor" href="#pool">#</a> pool</h3><ul><li><p>同一个 pool 中的 block 大小必须统一。<br><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/Image(69).png" alt="7b94ea10747352b5100ca504cdf76571.png"></p></li><li><p>pool 的大小一般为 4kb。</p></li><li><p>管理 block 的指针分为四种：</p><ul><li>bp 指针：指向当前使用 block。</li><li>free 指针：指向下一个可用 block，free 是一个链表，每个节点内的值为 Null 或者是下一个空闲的 block 地址。</li><li>next 指针：指向 free 的下一个空闲 block，一般是在当 free 内的值为 Null 的情况下，系统申请新空闲 block 后，给 free 作定位用的。</li><li>maxnext 指针：指向 block 的最后一个 block 的首地址。用于判断 block 是否已经全部分配完毕。<br><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/Image(70).png" alt="ba149b720cee23ad2d08f6d95bb29524.png"></li></ul></li><li><p>pool 的结构是由一个 pool_header 和一堆 block 组成的数组。它们是一个整体。</p></li><li><p>pool 的状态：</p><ul><li>used 状态。pool 中即存在被使用的 block，也存在未被使用的 block。</li><li>full 状态。pool 中所有 block 都在被使用。</li><li>empty 状态。pool 中所有 block 都未被使用。</li></ul></li><li><p>usedpools。所有正在被使用的 pool 的双向链表头。本身是一个 pool_header * 组成的数组，通过一点取巧的方式把每个指针和其前面 2 个位置的指针一起视为一个 pool_header 对象从而构成一个空的双向链表。</p></li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200919154449909.png" alt="image-20200919154449909"></p><h3 id="arena"><a class="anchor" href="#arena">#</a> arena</h3><ul><li><p>多个 pool 的管理者，每个 arena 的 pool 可以存在多个不同的 <code>size class index</code> 。<br><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200919154538226.png" alt="image-20200919154538226"></p></li><li><p>一个 arena 的大小为 256k，可容纳 64 个 pool。<br><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200919154553555.png" alt="image-20200919154553555"></p></li><li><p>arena 的结构是由一个 arena_object 指针和一堆 pool 组成的数组构成。不像 pool 一样，arena 的指针和内存是分离的。</p></li><li><p>arena 有两种状态</p><ul><li>未使用状态：arena_object 指针没有指向对应的 pool 组成的数组块。</li><li>使用状态：arena_object 指针已经指向对应的 pool 组成的数组块。</li></ul></li></ul><p><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200919154614444.png" alt="image-20200919154614444"><br><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200919154634438.png" alt="image-20200919154634438"></p><h3 id="arenas"><a class="anchor" href="#arenas">#</a> arenas</h3><ul><li>管理多个 arena 的对象指针的数组。</li><li>把 arena 分为两种状态：<ul><li>未使用状态：通过 arenas 的 unused_arena_objects 指针作为表头的单向链表所连接</li><li>使用状态：通过 arenas 的 used_arena_objects 指针作为表头的双向链表所连接</li></ul></li><li>多个 arenas 通过名为 nextarena 和 prevatrena 的指针所联系在一起。</li><li>初始化时创建的 arena 的数量为 16 个。之后如果未使用的 arena 不足时，会进行二倍的扩容。</li><li>扩容操作只会创建 arena 的指针，只有在 arena 将要被使用时，才会去分配一个 256k 的大小。</li><li>当前管理的 arena 的总数是由一个 int 类型的变量控制。每次扩容左移一位。当发生溢出（超过 2**32 或者分配的空间不足一个 arenas 的大小）时停止扩容操作。<br><img data-src="https://blog-1255596461.cos.ap-guangzhou.myqcloud.com/blog_pic/image-20200919154653554.png" alt="image-20200919154653554"></li></ul><p>参考：<span class="exturl" data-url="aHR0cDovL3drbGtlbi5tZS9wb3N0cy8yMDE1LzA4LzI5L3B5dGhvbi1zb3VyY2UtbWVtb3J5LTEuaHRtbA==">http://wklken.me/posts/2015/08/29/python-source-memory-1.html</span></p><p>参考：<span class="exturl" data-url="aHR0cDovL3drbGtlbi5tZS9wb3N0cy8yMDE1LzA4LzI5L3B5dGhvbi1zb3VyY2UtbWVtb3J5LTIuaHRtbA==">http://wklken.me/posts/2015/08/29/python-source-memory-2.html</span></p><h3 id="垃圾回收gc"><a class="anchor" href="#垃圾回收gc">#</a> 垃圾回收（GC）</h3><h4 id="1-标记清除marksweep"><a class="anchor" href="#1-标记清除marksweep">#</a> 1、标记清除（Mark——Sweep）</h4><ul><li>寻找根对象集合<ul><li>采用双向链表存储所有 container 对象</li><li>为此每个 container 对象头部都存在一个 PyGC_Head 的数据块（在 PyObject_Head 之前）</li></ul></li><li>寻找可达对象和不可达对象</li><li>广度探测</li><li>对于非 container 对象不进行检查<ul><li>一个对象如果不能存储其他对象的引用则被视为非 container 对象</li></ul></li><li>对于可达对象进行保留，不可达对象进行回收。</li></ul><h4 id="2-分代的垃圾收集python的解决办法"><a class="anchor" href="#2-分代的垃圾收集python的解决办法">#</a> 2、分代的垃圾收集 ——python 的解决办法</h4><ul><li><p>核心思想：</p><ul><li>根据内存的创建时间划分为不同的「代」</li><li>时间越「长」的对象其被回收的概率就「小」。</li><li>经过多次垃圾回收「存活」下来的对象则会被分配到回收周期更「长」的代中。</li><li>每个「代」在 python 中对应的是一个「链表」，python 总共把代分为三个。</li><li>第「0」个代的链表长度超过 700 时会触发垃圾回收（第一、二代都是 10）。python 还会借此机会清理其他的代。</li><li>python 对代的清理是通过把第 2 代到第 0 代的三个链表（也可能不足三个）进行 merge。最终链接到第 2 代的链表后，一口气执行垃圾回收，打上回收标记。</li><li>打上不可回收标记。通过有效引用计数，把计数不为「0」的对象打上不可回收标记。</li><li>把不可回收对象单独存放在一个集合内。并把这些对象中所引用的对象（并且这些引用对象打上了可回收标记），也加入这个集合（双向链表）。</li><li>对于定义了「 <code>__del__</code> 」的对象（finalizer 对象）需要单独用一个 PyListObject 来存放，在删除 finalizer 对象的时候先扣除该对象所引用的对象的引用计数，并清理引用列表，待到引用计数为 0 时再进行垃圾回收，保证回收对象已经不被任何对象引用。</li><li>三种存储回收对象的链表：<ul><li>reachable：保存每次需要回收的所有对象。</li><li>unreachable：保存双向引用的回收对象。</li><li>uncollectable：保存带有「 <code>__del__</code> 」函数的双向引用对象。</li></ul></li><li>正常情况下的对象会在计数为 0 的时候就被销毁，所以存在于 <code>root object</code> 的对象都是双向引用或者被系统引用的对象。后者一般不会被回收。</li></ul></li><li><p>有效引用计数（解决垃圾回收时环引用）：</p><ul><li>遍历所有需要回收的对象（在 root object 集合中）。根据对象类型，判断每个对象内的引用 是否也是需要回收的对象，如果是，则对他的引用计数「副本」进行「 <code>--</code> 」操作，最终引用计数副本为「0」的对象将被视为可能需要回收。</li></ul></li><li><p>注意事项：</p><ul><li>python 在回收垃圾的时候没办法保证顺序，尽量避免在「 <code>__del__</code> 」中引用其他对象。</li><li>python2.7 和 python3.+ 对于执行垃圾回收时，在「 <code>__del__</code> 」中引用其他对象这一操作所给出的解决方案有所不同。</li></ul></li></ul><div class="tags"><a href="/tags/Python/" rel="tag"><i class="ic i-tag"></i> Python</a> <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"><i class="ic i-tag"></i> 源码</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-12-29 09:36:04" itemprop="dateModified" datetime="2022-12-29T09:36:04+08:00">2022-12-29</time> </span><span id="learning/programlanguage/python/Python2-Source-Code/" class="item leancloud_visitors" data-flag-title="python2源码剖析" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 充电</button><p>请我[恰饭]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="鑫酱(●'◡'●) 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="鑫酱(●'◡'●) 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>鑫酱(●'◡'●) <i class="ic i-at"><em>@</em></i>鑫酱</li><li class="link"><strong>本文链接：</strong> <a href="https://hakuya.me/learning/programlanguage/python/Python2-Source-Code/" title="python2源码剖析">https://hakuya.me/learning/programlanguage/python/Python2-Source-Code/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/learning/linux/Shell-Grammar/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;wallpaper-1255596461.cos.ap-nanjing.myqcloud.com&#x2F;wallpaper (9).jpg" title="shell基本语法及linux基础"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> linux</span><h3>shell基本语法及linux基础</h3></a></div><div class="item right"><a href="/tasklist/plan-table/" itemprop="url" rel="next" data-background-image="&#x2F;assets&#x2F;plan-table-cover.jpg" title="计划表"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 任务清单</span><h3>计划表</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"><span class="toc-number">1.</span> <span class="toc-text">python 源码阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pyintobjectpython%E4%B8%AD%E7%9A%84int%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">PyIntObject——python 中的 int 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pystringobjectpython%E4%B8%AD%E7%9A%84string%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">PyStringObject——python 中的 string 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pylistobjectpython%E4%B8%AD%E7%9A%84list%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">PyListObject——python 中的 list 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pydictobjectpython%E4%B8%AD%E7%9A%84dict%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">PyDictObject——python 中的 dict 类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E7%9A%84%E7%BC%96%E8%AF%91%E7%BB%86%E8%8A%82"><span class="toc-number">1.2.</span> <span class="toc-text">python 的编译细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pyc%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">pyc 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pyframeobject%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">PyFrameObject 对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">1.3.</span> <span class="toc-text">python 控制流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">python 函数机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pyfunctionobject"><span class="toc-number">1.4.1.</span> <span class="toc-text">PyFunctionObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">函数参数实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%88%AB"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">参数类别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">参数数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">参数位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">扩展参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%85%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">函数内变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97-%E9%97%AD%E5%8C%85-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">嵌套、闭包、装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">嵌套函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85closure"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">闭包（closure）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8decorator"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">装饰器（decorator）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E7%B1%BB%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">python 类机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-type-%E5%AF%B9%E8%B1%A1%E5%88%B0-class-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">从 type 对象到 class 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E6%80%A7callable"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">可调用性（callable)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step1-%E5%A4%84%E7%90%86%E5%9F%BA%E7%B1%BBclass__base__%E5%92%8C-type-%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">Step.1 处理基类 ( class.__base__ ) 和 Type 信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step2-%E5%A4%84%E7%90%86%E5%9F%BA%E7%B1%BB%E5%88%97%E8%A1%A8class-__bases__"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">Step.2 处理基类列表 ( class .__bases__ )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step3-%E5%A1%AB%E5%85%85-tp_dictclass-__dict__"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">Step.3 填充 tp_dict ( class .__dict__ )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step4-%E5%AF%B9-slot-%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%85%B3%E8%81%94%E5%88%B0-descriptor"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">Step.4 对 slot 排序并关联到 descriptor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step5-%E7%A1%AE%E5%AE%9Amro%E5%88%97%E8%A1%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">Step.5 确定 mro 列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step6-%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">Step.6 继承基类操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step7-%E5%A1%AB%E5%85%85%E5%AD%90%E7%B1%BB%E5%88%97%E8%A1%A8class__subclasses__"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">Step.7 填充子类列表（ class.__subclasses__() ）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-class"><span class="toc-number">1.5.3.</span> <span class="toc-text">自定义 class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#descriptor%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">descriptor 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bound-method-%E5%92%8C-unbound-method"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">Bound Method 和 Unbound Method</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.</span> <span class="toc-text">python 运行环境初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-number">1.6.1.</span> <span class="toc-text">初始化线程环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">进程结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">线程结构：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9Fmodule"><span class="toc-number">1.6.2.</span> <span class="toc-text">加载系统 module</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA__builtin__-module"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">创建 __builtin__ module</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-sys-module"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">创建 sys module</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.6.3.</span> <span class="toc-text">激活虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">交互式运行方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">脚本文件运行方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">启动虚拟机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">名字空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.</span> <span class="toc-text">python 模块动态加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#import-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">import 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E9%94%80%E6%AF%81%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.2.</span> <span class="toc-text">模块销毁与重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%80%E6%AF%81"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#import-%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">import 实现机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#legb-%E8%A7%84%E5%88%99"><span class="toc-number">1.7.4.</span> <span class="toc-text">LEGB 规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%86%85%E5%B5%8C%E4%BD%9C%E7%94%A8%E5%9F%9F-%E8%A7%84%E5%88%99"><span class="toc-number">1.7.5.</span> <span class="toc-text">最内嵌作用域 规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.</span> <span class="toc-text">python 多线程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gil%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.8.1.</span> <span class="toc-text">GIL (全局解释器锁) 和线程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.8.2.</span> <span class="toc-text">Python 线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">建立多线程环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.8.2.1.1.</span> <span class="toc-text">子线程的创建步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.2.1.2.</span> <span class="toc-text">线程状态保护机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.8.3.</span> <span class="toc-text">Python 线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%B0%83%E5%BA%A6"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">标准调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E8%B0%83%E5%BA%A6"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">阻塞调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">1.8.4.</span> <span class="toc-text">Python 子线程的销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%A8%E6%88%B7%E7%BA%A7%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.8.5.</span> <span class="toc-text">Python 线程的用户级互斥与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">Lock 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%BA%93threading"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">高级线程库 ——threading</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#threading-module-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.8.5.3.</span> <span class="toc-text">Threading Module 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#threading-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">1.8.5.4.</span> <span class="toc-text">Threading 的线程同步工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6gc"><span class="toc-number">1.9.</span> <span class="toc-text">python 的垃圾回收 GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#block"><span class="toc-number">1.9.1.</span> <span class="toc-text">block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pool"><span class="toc-number">1.9.2.</span> <span class="toc-text">pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arena"><span class="toc-number">1.9.3.</span> <span class="toc-text">arena</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arenas"><span class="toc-number">1.9.4.</span> <span class="toc-text">arenas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6gc"><span class="toc-number">1.9.5.</span> <span class="toc-text">垃圾回收（GC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4marksweep"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">1、标记清除（Mark——Sweep）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%86%E4%BB%A3%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86python%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">2、分代的垃圾收集 ——python 的解决办法</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/learning/programlanguage/python/Python-Build-In/" rel="bookmark" title="python内建函数">python内建函数</a></li><li><a href="/learning/programlanguage/python/Python2-Diff-Python3/" rel="bookmark" title="python2和python3差异">python2和python3差异</a></li><li><a href="/learning/programlanguage/python/Python2-Yield-Async/" rel="bookmark" title="python2解决异步协程问题">python2解决异步协程问题</a></li><li class="active"><a href="/learning/programlanguage/python/Python2-Source-Code/" rel="bookmark" title="python2源码剖析">python2源码剖析</a></li><li><a href="/learning/programlanguage/python/Python-C-extension/" rel="bookmark" title="编写Python的C扩展">编写Python的C扩展</a></li><li><a href="/learning/programlanguage/python/Python-watchdog/" rel="bookmark" title="基于 watchdog 实现自动化更新">基于 watchdog 实现自动化更新</a></li><li><a href="/learning/programlanguage/python/Python-HotFix/" rel="bookmark" title="Python HotFix 热更新">Python HotFix 热更新</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="鑫酱(●'◡'●)" data-src="/images/avatar.jpg"><p class="name" itemprop="name">鑫酱(●'◡'●)</p><div class="description" itemprop="description">整天摸鱼，却妄想拯救世界的技术宅</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">98</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">24</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">51</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsbGVuR1g=" title="https:&#x2F;&#x2F;github.com&#x2F;AllenGX"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTgwNTM4MjQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;80538242"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjE0MTM5MDcxNTNAcXEuY29t" title="mailto:1413907153@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>好友</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>网址</a></li><li class="item"><a href="/travellings/" rel="section"><i class="ic i-paper-plane"></i>传送门</a></li><li class="item"><a href="/mikutap/" rel="section"><i class="ic i-star"></i>Mikutap</a></li><li class="item"><a href="/restart/" rel="section"><i class="ic i-sun"></i>RestartLife</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/learning/linux/Shell-Grammar/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/tasklist/plan-table/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/read/" title="分类于 阅读">阅读</a> <i class="ic i-angle-right"></i> <a href="/categories/read/psychology/" title="分类于 心理学">心理学</a></div><span><a href="/read/psychology/%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E3%80%8C4%E3%80%8D/" title="少有人走的路「4」，在焦虑的年代获得精神的成长">少有人走的路「4」，在焦虑的年代获得精神的成长</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/" title="分类于 编程语言">编程语言</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/learning/programlanguage/cpp/%E5%9B%9B%E3%80%81%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/" title="四、复合类型">四、复合类型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game202/" title="分类于 GAME202高质量实时渲染">GAME202高质量实时渲染</a></div><span><a href="/learning/games/Game202/%E4%B8%80%E3%80%81Recap%20of%20CG%20Basics/" title="一、Recap of CG Basics">一、Recap of CG Basics</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game101/" title="分类于 Games101图形渲染">Games101图形渲染</a></div><span><a href="/learning/games/Game101/%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81Animation%EF%BC%88%E4%B8%8A%EF%BC%89/" title="二十三、Animation（上）">二十三、Animation（上）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/" title="分类于 编程语言">编程语言</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/python/" title="分类于 python">python</a></div><span><a href="/learning/programlanguage/python/Python-C-extension/" title="编写Python的C扩展">编写Python的C扩展</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game101/" title="分类于 Games101图形渲染">Games101图形渲染</a></div><span><a href="/learning/games/Game101/%E4%B8%80%E3%80%81Linear%20Algebra/" title="一、Linear Algebra">一、Linear Algebra</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/japanese/" title="分类于 日语">日语</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/japanese/primary/" title="分类于 日语初级">日语初级</a></div><span><a href="/learning/japanese/primary/%E4%B8%80%E3%80%81%E5%B0%8F%E6%9D%8E%E8%B5%B4%E6%97%A5/" title="一、小李赴日">一、小李赴日</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/" title="分类于 编程语言">编程语言</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/learning/programlanguage/cpp/%E5%8D%81%E5%9B%9B%E3%80%81C++%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/" title="十四、C++中的代码重用">十四、C++中的代码重用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/" title="分类于 编程语言">编程语言</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/programlanguage/cpp/" title="分类于 cpp">cpp</a></div><span><a href="/learning/programlanguage/cpp/C++%E4%B8%AD%E7%9A%84extern/" title="C++中的extern">C++中的extern</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/learning/" title="分类于 学习">学习</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/" title="分类于 Games系列">Games系列</a> <i class="ic i-angle-right"></i> <a href="/categories/learning/games/Game101/" title="分类于 Games101图形渲染">Games101图形渲染</a></div><span><a href="/learning/games/Game101/%E5%8D%81%E4%B9%9D%E3%80%81Advanced%20Topics%20in%20Rendering%E2%80%94%E2%80%94Light%20Transport/" title="十九、Advanced Topics in Rendering——Light Transport">十九、Advanced Topics in Rendering——Light Transport</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">鑫酱(●'◡'●) @ 个人博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">520k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">7:52</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"learning/programlanguage/python/Python2-Source-Code/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/animejs@3.2.0/lib/anime.min.js,npm/katex@0.12.0/dist/contrib/copy-tex.min.js,npm/frappe-charts@1.5.0/dist/frappe-charts.min.iife.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/quicklink@2/dist/quicklink.umd.js,gh/amehime/MiniValine@4.2.2-beta10/dist/MiniValine.min.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b6d809b500bd6f0040117088899bc7bf";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>